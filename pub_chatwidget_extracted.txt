{__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_chatUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../utils/chatUtils */ \"./src/utils/chatUtils.js\");
/* harmony import */ var hooks_useWidgetInstance__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! hooks/useWidgetInstance */ \"./src/hooks/useWidgetInstance.js\");
/* harmony import */ var hooks_useChatCache__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! hooks/useChatCache */ \"./src/hooks/useChatCache.js\");
/* harmony import */ var _hooks_useConversationCache__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../hooks/useConversationCache */ \"./src/hooks/useConversationCache.js\");
/* harmony import */ var react_transition_group__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-transition-group */ \"./node_modules/react-transition-group/esm/CSSTransition.js\");
/* harmony import */ var react_transition_group__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react-transition-group */ \"./node_modules/react-transition-group/esm/SwitchTransition.js\");
/* harmony import */ var layouts_widget_WidgetStyles_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! layouts/widget/WidgetStyles.css */ \"./src/layouts/widget/WidgetStyles.css\");
/* harmony import */ var layouts_widget_WidgetStyles_css__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(layouts_widget_WidgetStyles_css__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! uuid */ \"./node_modules/uuid/dist/esm-browser/v4.js\");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var config_environment__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! config/environment */ \"./src/config/environment.js\");
/* harmony import */ var services_signalr__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! services/signalr */ \"./src/services/signalr.js\");
/* harmony import */ var _chat_InputArea__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./chat/InputArea */ \"./src/layouts/bot/style/components/chat/InputArea.js\");
/* harmony import */ var _chat_MessageBubble__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./chat/MessageBubble */ \"./src/layouts/bot/style/components/chat/MessageBubble.js\");
/* harmony import */ var _chat_MessageList__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./chat/MessageList */ \"./src/layouts/bot/style/components/chat/MessageList.js\");
/* harmony import */ var _chat_TypingDots__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./chat/TypingDots */ \"./src/layouts/bot/style/components/chat/TypingDots.js\");
/* harmony import */ var _chat_ImagePreviewModal__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./chat/ImagePreviewModal */ \"./src/layouts/bot/style/components/chat/ImagePreviewModal.js\");
/* harmony import */ var _chat_DeviceConflictOverlay__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./chat/DeviceConflictOverlay */ \"./src/layouts/bot/style/components/chat/DeviceConflictOverlay.js\");
/* harmony import */ var _chat_MobileConversationExpired__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./chat/MobileConversationExpired */ \"./src/layouts/bot/style/components/chat/MobileConversationExpired.js\");
/* harmony import */ var services_botService__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! services/botService */ \"./src/services/botService.js\");
/* harmony import */ var services_chatService__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! services/chatService */ \"./src/services/chatService.js\");
/* harmony import */ var services_conversationsService__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! services/conversationsService */ \"./src/services/conversationsService.js\");
/* harmony import */ var services_fingerprintService__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! services/fingerprintService */ \"./src/services/fingerprintService.js\");
/* harmony import */ var _utils_colors__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../../../../utils/colors */ \"./src/utils/colors.js\");
/* harmony import */ var qrcode_react__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! qrcode.react */ \"./node_modules/qrcode.react/lib/esm/index.js\");
/* harmony import */ var hooks_useDeviceSessionLock__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! hooks/useDeviceSessionLock */ \"./src/hooks/useDeviceSessionLock.js\");



























// Para widgets embebidos, usar ruta absoluta del servidor del dashboard
const viaLogo = \"http://localhost:3000/VIA.png\";
const defaultAvatar = \"http://localhost:3000/VIA.png\";
const pastelColors = {
  conectado: \"#b3e5fc\",
  // azul pastel actual
  reconectando: \"#fff9c4\",
  // amarillo pastel
  error: \"#ffcdd2\",
  // rosa pastel
  desconectado: \"#ffcc80\",
  // naranja pastel
  conectadoVerde: \"#b9fbc0\" // verde pastel que quieres usar
};
function ChatWidget({
  style = {},
  theme: initialTheme,
  botId: propBotId,
  userId: propUserId,
  isDemo: initialDemo = false,
  widgetToken: propWidgetToken = null,
  widgetClientSecret: propWidgetClientSecret = null,
  rootRef = null,
  containerSize = null,
  previewMode = false,
  isMobileView = false,
  conversationId: propConversationId = null
}) {
  // Modulariza la instancia y la clave de cachÃ©
  const {
    botId,
    userId,
    widgetInstanceId,
    CACHE_KEY
  } = (0,hooks_useWidgetInstance__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(propBotId, propUserId);

  // Inicializa conversationId y mensajes desde cachÃ© si no hay propConversationId
  const cached = (0,_hooks_useConversationCache__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(CACHE_KEY).loadConversationCache();
  const initialConversationId = propConversationId || cached?.conversationId || cached?.messages?.[0]?.conversationId || null;
  const [conversationId, setConversationId] = (0,react__WEBPACK_IMPORTED_MODULE_7__.useState)(initialConversationId);

  // Estado para la URL del QR y fingerprint
  const [qrUrl, setQrUrl] = (0,react__WEBPACK_IMPORTED_MODULE_7__.useState)(\"\");
  const [fingerprint, setFingerprint] = (0,react__WEBPACK_IMPORTED_MODULE_7__.useState)(\"\");

  // URL del QR del header: se actualiza cuando cambia token, fingerprint o conversationId
  const [headerQrUrl, setHeaderQrUrl] = (0,react__WEBPACK_IMPORTED_MODULE_7__.useState)(\"\");

  // Efecto para generar la URL del QR con fingerprint y token (para que mÃ³vil pueda conectar a SignalR)
  (0,react__WEBPACK_IMPORTED_MODULE_7__.useEffect)(() => {
    if (!conversationId || !fingerprint) {
      setQrUrl(\"\");
      if (!fingerprint) {
        console.warn('[ChatWidget] fingerprint aÃºn no estÃ¡ listo para QR:', {
          userId,
          fingerprint
        });
      }
      return;
    }
    let url = `${window.location.origin}/chat/mobile?bot=${botId}&conversation=${conversationId}&userId=${userId}&fingerprint=${fingerprint}`;
    const secret = propWidgetClientSecret ?? null;
    if (secret && typeof secret === 'string') {
      url += `&token=${encodeURIComponent(secret)}`;
    }
    setQrUrl(url);
    console.log('[ChatWidget] QR generado:', url);
  }, [botId, conversationId, userId, fingerprint, propWidgetClientSecret]);

  // Efecto que mantiene la URL del QR del header siempre actualizada (incluye token en cuanto estÃ© disponible)
  (0,react__WEBPACK_IMPORTED_MODULE_7__.useEffect)(() => {
    const conv = conversationId || conversationIdRef.current;
    if (!botId || !conv) {
      setHeaderQrUrl(\"\");
      return;
    }
    const base = \"http://localhost:3000\" || (0);
    const params = new URLSearchParams();
    params.set('bot', String(botId));
    params.set('conversation', String(conv));
    if (userId != null && userId !== '') params.set('userId', String(userId));
    if (fingerprint) params.set('fingerprint', fingerprint);
    if (propWidgetClientSecret && typeof propWidgetClientSecret === 'string') params.set('token', propWidgetClientSecret);
    const url = `${base}/chat/mobile?${params.toString()}`;
    setHeaderQrUrl(url);
  }, [botId, conversationId, userId, fingerprint, propWidgetClientSecret]);

  // Obtener fingerprint al montar el componente
  (0,react__WEBPACK_IMPORTED_MODULE_7__.useEffect)(() => {
    let mounted = true;
    (0,services_fingerprintService__WEBPACK_IMPORTED_MODULE_22__.getOrGenerateFingerprint)().then(fp => {
      if (mounted) setFingerprint(fp);
    });
    return () => {
      mounted = false;
    };
  }, []);

  // âœ… Crear ref interno si no se pasa rootRef como prop
  const internalRootRef = (0,react__WEBPACK_IMPORTED_MODULE_7__.useRef)(null);
  const actualRootRef = rootRef || internalRootRef;

  // Estados y hooks principales
  const connectionRef = (0,react__WEBPACK_IMPORTED_MODULE_7__.useRef)(null);
  // widgetClientSecret se usa directamente desde propWidgetClientSecret (parÃ¡metro de funciÃ³n)
  const conversationIdRef = (0,react__WEBPACK_IMPORTED_MODULE_7__.useRef)(propConversationId); // Inicializar con prop
  const [isOpen, setIsOpen] = (0,react__WEBPACK_IMPORTED_MODULE_7__.useState)(isMobileView); // Si es mÃ³vil, abrir por defecto
  const [botStyle, setBotStyle] = (0,react__WEBPACK_IMPORTED_MODULE_7__.useState)(style || null);
  const [isDemo, setIsDemo] = (0,react__WEBPACK_IMPORTED_MODULE_7__.useState)(initialDemo);
  const [botContext, setBotContext] = (0,react__WEBPACK_IMPORTED_MODULE_7__.useState)(null);
  // ...ya inicializado arriba desde cachÃ©...
  const [isBotReady, setIsBotReady] = (0,react__WEBPACK_IMPORTED_MODULE_7__.useState)(initialDemo);
  const [promptSent, setPromptSent] = (0,react__WEBPACK_IMPORTED_MODULE_7__.useState)(false);
  const promptSentRef = (0,react__WEBPACK_IMPORTED_MODULE_7__.useRef)(false);
  const [isConnected, setIsConnected] = (0,react__WEBPACK_IMPORTED_MODULE_7__.useState)(false); // ESTA LÃNEA DEBE ESTAR AQUÃ
  const [welcomeMessage, setWelcomeMessage] = (0,react__WEBPACK_IMPORTED_MODULE_7__.useState)(null);
  const [userLocation, setUserLocation] = (0,react__WEBPACK_IMPORTED_MODULE_7__.useState)(null); // { country, city, language }
  const [capturedFields, setCapturedFields] = (0,react__WEBPACK_IMPORTED_MODULE_7__.useState)([]); // ðŸ†• Estado para track de campos capturados
  const [isMobileConversationExpired, setIsMobileConversationExpired] = (0,react__WEBPACK_IMPORTED_MODULE_7__.useState)(false); // Estado para conversaciÃ³n expirada en mÃ³vil
  const [isMobileSessionActive, setIsMobileSessionActive] = (0,react__WEBPACK_IMPORTED_MODULE_7__.useState)(false); // ðŸ†• Pausa inactividad cuando mÃ³vil estÃ¡ abierto
  const [fileInputKey, setFileInputKey] = (0,react__WEBPACK_IMPORTED_MODULE_7__.useState)(0); // ðŸ”„ Forzar input file fresco tras cada subida (evita que no dispare onChange en 2Âª imagen)
  const welcomeShownRef = (0,react__WEBPACK_IMPORTED_MODULE_7__.useRef)(false); // ðŸ†• Ref para rastrear si ya mostrÃ³ bienvenida en esta conversaciÃ³n
  const welcomeTimeoutRef = (0,react__WEBPACK_IMPORTED_MODULE_7__.useRef)(null); // ðŸ†• Ref para rastrear el timeout del mensaje de bienvenida
  const lastWelcomeTextRef = (0,react__WEBPACK_IMPORTED_MODULE_7__.useRef)(null); // ðŸ†• Ref para guardar el texto del welcome enviado, evitar duplicados del broadcast
  // Hook para cachÃ© y sesiÃ³n modularizado
  const {
    saveConversationCache,
    loadConversationCache,
    clearCache,
    loadedConversationsRef
  } = (0,_hooks_useConversationCache__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(CACHE_KEY);
  const widgetExplicitlyClosedRef = (0,react__WEBPACK_IMPORTED_MODULE_7__.useRef)(false); // ðŸ†• Ref para rastrear si el usuario cerrÃ³ el widget explÃ­citamente
  const qrHistoryLoadedRef = (0,react__WEBPACK_IMPORTED_MODULE_7__.useRef)(false); // ðŸ†• Ref para evitar cargar historial QR dos veces

  // Declarar initialMessages antes de usarlo en el estado
  const initialMessages = (() => {
    const cached = loadConversationCache();
    return cached?.messages?.length ? cached.messages : [];
  })();
  const [messages, setMessages] = (0,react__WEBPACK_IMPORTED_MODULE_7__.useState)(initialMessages);

  // El hook debe usarse solo en la web, no en mÃ³vil
  const deviceSessionLock = (0,hooks_useDeviceSessionLock__WEBPACK_IMPORTED_MODULE_25__[\"default\"])(conversationId, connectionRef.current, false // Siempre false para la web, el mÃ³vil no debe bloquearse a sÃ­ mismo
  );
  const [isBlockedByOtherDevice, setIsBlockedByOtherDevice] = (0,react__WEBPACK_IMPORTED_MODULE_7__.useState)(deviceSessionLock.isBlockedByOtherDevice);
  const [blockMessage, setBlockMessage] = (0,react__WEBPACK_IMPORTED_MODULE_7__.useState)(deviceSessionLock.blockMessage);
  const blockingDevice = deviceSessionLock.blockingDevice;

  // Log para verificar el estado de bloqueo
  (0,react__WEBPACK_IMPORTED_MODULE_7__.useEffect)(() => {
    setIsBlockedByOtherDevice(deviceSessionLock.isBlockedByOtherDevice);
    setBlockMessage(deviceSessionLock.blockMessage);
  }, [deviceSessionLock.isBlockedByOtherDevice, deviceSessionLock.blockMessage]);

  // Para animaciÃ³n del mensaje de debug
  const [connectionStatus, setConnectionStatus] = (0,react__WEBPACK_IMPORTED_MODULE_7__.useState)(\"desconocido\");
  const [showConnectionDebug, setShowConnectionDebug] = (0,react__WEBPACK_IMPORTED_MODULE_7__.useState)(false);
  const previousConnectionStatusRef = (0,react__WEBPACK_IMPORTED_MODULE_7__.useRef)(connectionStatus);
  const nodeRef = (0,react__WEBPACK_IMPORTED_MODULE_7__.useRef)(null);
  const wasBlockedRef = (0,react__WEBPACK_IMPORTED_MODULE_7__.useRef)(false); // ðŸ”¹ Ref para rastrear estado previo del bloqueo

  // ðŸ†• EFFECT: Guardar token en localStorage cuando estÃ© disponible
  // Esto asegura que axiosConfig pueda encontrarlo cuando llame a getConversationHistory()
  (0,react__WEBPACK_IMPORTED_MODULE_7__.useEffect)(() => {
    // Si necesitas guardar el token, usa saveCache o una funciÃ³n dedicada
  }, [propWidgetToken]);

  // ðŸ†• EFFECT: Escuchar eventos postMessage desde mÃ³vil
  (0,react__WEBPACK_IMPORTED_MODULE_7__.useEffect)(() => {
    const handleMobileMessage = async event => {
      // Verificar origen si es necesario
      if (event.data && event.data.type === 'mobile-inactivity-expired') {
        try {
          // Limpiar todo cuando mÃ³vil expira por inactividad
          clearCache();
          sessionStorage.removeItem(CACHE_KEY);
          localStorage.removeItem(CACHE_KEY);
          setConversationId(null);
          conversationIdRef.current = null;
          setQrUrl(\"\");
          setMessages([]);
          setPromptSent(false);
          promptSentRef.current = false;
          welcomeShownRef.current = false;
          loadedConversationsRef.current = new Set();
          setIsOpen(false);
          console.log(`âœ… [Widget] Limpiado tras inactividad mÃ³vil`);
        } catch (e) {
          console.error('âŒ [Widget] Error al limpiar tras inactividad mÃ³vil:', e);
        }
      }
    };
    window.addEventListener('message', handleMobileMessage);
    return () => {
      window.removeEventListener('message', handleMobileMessage);
    };
  }, [CACHE_KEY]);

  // EFFECT: Detectar cuando la conversaciÃ³n es cerrada en web (mÃ³vil entra en standby)
  // O cuando estÃ¡ bloqueada por otro dispositivo
  (0,react__WEBPACK_IMPORTED_MODULE_7__.useEffect)(() => {
    if (!isMobileView || !conversationIdRef.current) return;

    // ðŸ”’ CAMBIO: Cuando web se abre, CERRAR mÃ³vil automÃ¡ticamente
    if (isBlockedByOtherDevice) {
      console.log('ðŸ”’ [Mobile] Web estÃ¡ activo en esta conversaciÃ³n - cerrando mÃ³vil automÃ¡ticamente');
      // Cerrar el widget automÃ¡ticamente en mÃ³vil
      setIsOpen(false);
      setIsMobileConversationExpired(true);
    } else if (wasBlockedRef.current && !isBlockedByOtherDevice) {
      // Caso anterior: Si la sesiÃ³n fue desbloqueada despuÃ©s de estar bloqueada
      setIsMobileConversationExpired(true);
    }
    wasBlockedRef.current = isBlockedByOtherDevice;
  }, [isBlockedByOtherDevice, isMobileView]);

  // ðŸ†• EFFECT: Actualizar estado de sesiÃ³n mÃ³vil activa
  // Cuando web estÃ¡ bloqueado por mÃ³vil, pausar inactividad en web
  (0,react__WEBPACK_IMPORTED_MODULE_7__.useEffect)(() => {
    if (!isMobileView) {
      // Si NO es mÃ³vil (es web), verificar si estÃ¡ bloqueado por mÃ³vil
      if (isBlockedByOtherDevice) {
        setIsMobileSessionActive(true);
      } else {
        setIsMobileSessionActive(false);
      }
    } else {
      // Si ES mÃ³vil, la sesiÃ³n mÃ³vil estÃ¡ activa cuando el widget estÃ¡ abierto
      if (isOpen) {
        setIsMobileSessionActive(true);
      } else {
        setIsMobileSessionActive(false);
      }
    }
  }, [isBlockedByOtherDevice, isOpen, isMobileView]);

  // Estado de debug
  (0,react__WEBPACK_IMPORTED_MODULE_7__.useEffect)(() => {
    if (connectionStatus !== previousConnectionStatusRef.current) {
      // Mostrar mensaje temporal al cambiar el estado
      setShowConnectionDebug(true);
      const timeout = setTimeout(() => setShowConnectionDebug(false), 3000);
      previousConnectionStatusRef.current = connectionStatus;
      return () => clearTimeout(timeout);
    }
  }, [connectionStatus]);
  (0,react__WEBPACK_IMPORTED_MODULE_7__.useEffect)(() => {
    if (initialDemo) return;
    const fetchBotStyleAndContext = async () => {
      try {
        // ðŸ”¹ Estilos
        const res = await fetch(`http://localhost:5006/api/Bots/${botId}`);
        const data = await res.json();
        if (data.style) {
          setBotStyle(data.style);
          // No cambiar isDemo si initialDemo es true
          if (!initialDemo) {
            setIsDemo(false);
          }
        }

        // ðŸ”¹ Obtener ubicaciÃ³n del usuario (desde endpoint de conversaciones)
        try {
          // ðŸ§ª PARA TESTING: Simular diferentes ubicaciones descomenta una de estas lÃ­neas:
          // const testIP = \"213.97.99.0\"; // EspaÃ±a (Madrid)
          const testIP = \"190.147.2.0\"; // Colombia (Bogota)
          // const testIP = \"203.113.168.0\"; // JapÃ³n

          const locationRes = await fetch(`http://localhost:5006/api/conversations/user-location`, {
            method: 'GET',
            credentials: 'include',
            headers: {
              'X-Forwarded-For': testIP
            }
          });
          if (locationRes.ok) {
            const locationData = await locationRes.json();
            setUserLocation({
              country: locationData.country || 'Unknown',
              city: locationData.city || 'Unknown',
              language: 'es'
            });
          } else {
            setUserLocation({
              country: 'Unknown',
              city: 'Unknown',
              language: 'es'
            });
          }
        } catch (err) {
          setUserLocation({
            country: 'Unknown',
            city: 'Unknown',
            language: 'es'
          });
        }

        // ðŸ”¹ Contexto
        const context = await (0,services_botService__WEBPACK_IMPORTED_MODULE_19__.getBotContext)(botId);
        if (context) {
          // Preparamos los mensajes para la IA
          const systemMsg = context.messages.find(m => m.role === \"system\");
          const otherMsgs = context.messages.filter(m => m.role !== \"system\");
          const messagesForAI = [];
          if (systemMsg) messagesForAI.push(systemMsg);
          messagesForAI.push(...otherMsgs);

          // Creamos un payload completo para usarlo al enviar a la IA
          const aiPayload = {
            botId: context.botId,
            name: context.name,
            description: context.description,
            provider: context.provider,
            settings: context.settings,
            messages: messagesForAI,
            training: context.training,
            capture: context.capture
          };

          // ðŸ†• Inicializar campos capturados desde el contexto
          if (context.capture?.fields && Array.isArray(context.capture.fields)) {
            const initialFields = context.capture.fields.map(field => ({
              fieldName: field.fieldName,
              value: null,
              // Inicialmente no hay valor capturado
              fieldType: field.fieldType || \"text\",
              isRequired: field.isRequired || false
            }));
            setCapturedFields(initialFields);
          }

          // ðŸ”¹ Guardamos el payload en el estado
          setBotContext(aiPayload);
          setIsBotReady(true); // âœ… El bot estÃ¡ listo para recibir mensajes

          // ðŸ”¹ Guardamos el system prompt + vector info para uso interno de la IA
          const systemPrompt = systemMsg?.content || \"\";
          const trainingData = aiPayload.training || {};
          const vectorInfo = `Fuentes disponibles:\
- Documentos: ${trainingData.documents?.length || 0}\
- URLs: ${trainingData.urls?.length || 0}\
- Textos: ${trainingData.customTexts?.join(\", \") || \"Ninguno\"}`;
          const initialPrompt = `${systemPrompt}\
\
AdemÃ¡s, tienes acceso a datos vectorizados relacionados con este bot.\
Utiliza esos datos siempre que sean relevantes para responder.\
\
${vectorInfo}`;

          // ðŸ”¹ Guardar prompt interno en botContext
          setBotContext(prev => ({
            ...prev,
            initialPrompt
          }));
        }
      } catch (err) {
        setIsBotReady(false); // Asegurarse de que no estÃ© listo si falla
      }
    };
    fetchBotStyleAndContext();
  }, [botId]);

  // ðŸ”¹ Obtener mensaje de bienvenida personalizado
  (0,react__WEBPACK_IMPORTED_MODULE_7__.useEffect)(() => {
    if (!userLocation || !botId || initialDemo) {
      return;
    }
    const fetchWelcomeMessage = async () => {
      try {
        const params = new URLSearchParams({
          botId: botId,
          country: userLocation.country || 'Unknown',
          city: userLocation.city || 'Unknown',
          language: userLocation.language || 'es'
        });
        const url = `${config_environment__WEBPACK_IMPORTED_MODULE_10__.API_URL}/botwelcomemessages/get-by-location?${params}`;
        console.log('ðŸ” [WELCOME] Solicitando mensaje de bienvenida:', {
          url,
          botId,
          country: userLocation.country,
          city: userLocation.city,
          language: userLocation.language
        });
        const response = await fetch(url, {
          credentials: 'include'
        });
        if (response.ok) {
          const data = await response.json();
          console.log('âœ… [WELCOME] Respuesta del servidor:', data);
          setWelcomeMessage({
            text: data.message,
            country: data.country,
            city: data.city,
            matchType: data.matchType,
            source: data.source
          });
        } else {
          const errorData = await response.json();
          console.error('âŒ [WELCOME] Error en respuesta:', {
            status: response.status,
            errorData
          });
        }
      } catch (err) {
        console.error('âŒ [WELCOME] Error en fetch:', err);
      }
    };
    fetchWelcomeMessage();
  }, [userLocation, botId, initialDemo]);

  // ðŸ”¹ NOTA: Los handlers de reconexiÃ³n (onreconnecting, onreconnected, onclose) 
  // ahora se registran directamente en initConnection() para asegurar que siempre
  // tengan acceso a la conexiÃ³n correcta.

  // Mostrar TypingDots y mensaje de bienvenida solo al abrir el widget EN WEB
  // En mÃ³vil: NO mostrar si ya hay historial (conversaciÃ³n iniciada)
  (0,react__WEBPACK_IMPORTED_MODULE_7__.useEffect)(() => {
    if (isOpen && !isDemo && !welcomeShownRef.current) {
      const welcomeId = \"welcome-message\";
      const hasWelcome = messages.some(m => m.id === welcomeId);

      // ðŸ”¹ NO mostrar bienvenida si:
      // 1. Ya estÃ¡ en los mensajes
      // 2. Hay cualquier mensaje (historial cargado desde backend)
      // 3. Es mÃ³vil Y hay mÃ¡s de 0 mensajes (conversaciÃ³n iniciada)
      if (hasWelcome || messages.length > 0) {
        welcomeShownRef.current = true;
        return;
      }

      // ðŸ”¹ Esperar a que el mensaje personalizado estÃ© disponible
      if (!welcomeMessage) {
        console.log('â³ [WELCOME] Esperando mensaje personalizado...', {
          welcomeMessage
        });
        return; // Esperar al prÃ³ximo ciclo cuando welcomeMessage estÃ© disponible
      }
      console.log('ðŸ“ [WELCOME] Usando mensaje de bienvenida:', welcomeMessage);

      // ðŸ”¹ Limpiar timeout anterior si existe
      if (welcomeTimeoutRef.current) {
        clearTimeout(welcomeTimeoutRef.current);
        welcomeTimeoutRef.current = null;
      }

      // ðŸ”¹ Usar el mensaje personalizado si existe, sino el default
      const welcomeText = welcomeMessage?.text || \"ðŸ‘‹ Â¡Hola! Bienvenido. Â¿En quÃ© puedo ayudarte hoy?\";
      console.log('ðŸ’¬ [WELCOME] Texto final:', welcomeText);
      const welcomeMsg = {
        id: welcomeId,
        from: \"bot\",
        text: welcomeText,
        status: \"sent\",
        timestamp: new Date().toISOString()
      };

      // ðŸ”¹ MARCAR COMO MOSTRADO ANTES DE SCHEDULEAR - evita duplicados
      welcomeShownRef.current = true;
      setTypingSender(\"bot\");
      setIsTyping(true);
      const typingDelay = 1500 + Math.random() * 1000;
      welcomeTimeoutRef.current = setTimeout(async () => {
        // ðŸ†• Agregar el mensaje de bienvenida al estado local (SOLO UNA VEZ)
        setMessages(prev => {
          const alreadyExists = prev.some(m => m.id === welcomeId);
          if (alreadyExists) {
            return prev;
          }
          return [...prev, (0,_utils_chatUtils__WEBPACK_IMPORTED_MODULE_0__.normalizeMessage)(welcomeMsg)];
        });
        // (Eliminado log de estado de mensajes tras bienvenida)
        setPromptSent(true);
        promptSentRef.current = true;
        // ðŸ†• Guardar el mensaje de bienvenida en la conversaciÃ³n via SignalR
        // Como respuesta inicial de la IA (NO como entrada del usuario)
        try {
          const connection = connectionRef.current;
          const convId = conversationIdRef.current;
          if (connection && connection.state === \"Connected\" && convId) {
            lastWelcomeTextRef.current = welcomeText;
            await connection.invoke(\"SaveWelcomeMessage\", convId, welcomeText, botId);
          }
        } catch (err) {}
        requestAnimationFrame(() => {
          setIsTyping(false);
          setTypingSender(null);
        });
      }, typingDelay);
    }
    return () => {
      // Limpiar timeout al desmontar o cuando cambian las dependencias
      if (welcomeTimeoutRef.current) {
        clearTimeout(welcomeTimeoutRef.current);
        welcomeTimeoutRef.current = null;
      }
    };
  }, [isOpen, isDemo, isMobileView, welcomeMessage, botId]);

  // ConfiguraciÃ³n de temas
  const fallbackTextColor = \"#1a1a1a\";
  const fallbackBgColor = \"#f5f5f5\";
  const normalizedStyle = {
    ...style,
    primaryColor: style.primaryColor || style.PrimaryColor || style.primary_color || \"#000000\",
    secondaryColor: style.secondaryColor || style.SecondaryColor || style.secondary_color || \"#ffffff\",
    fontFamily: style.fontFamily || style.FontFamily || style.font_family || \"Arial\",
    avatarUrl: style.avatarUrl || style.AvatarUrl || style.avatar_url || \"\",
    headerBackgroundColor: style.headerBackgroundColor || style.HeaderBackgroundColor || style.header_background_color || \"\",
    allowImageUpload: style.allowImageUpload ?? style.AllowImageUpload ?? style.allow_image_upload ?? false,
    allowFileUpload: style.allowFileUpload ?? style.AllowFileUpload ?? style.allow_file_upload ?? false,
    position: style.position || style.Position || \"bottom-right\",
    width: style.width ?? style.Width ?? 380,
    height: style.height ?? style.Height ?? 600,
    title: style.title || style.Title || \"\",
    theme: style.theme || style.Theme || \"light\",
    customCss: style.customCss || style.CustomCss || style.custom_css || \"\"
  };
  const effectiveStyle = initialDemo ? normalizedStyle : botStyle || normalizedStyle;
  const {
    allowImageUpload,
    allowFileUpload,
    theme: themeKeyRaw,
    primaryColor,
    secondaryColor,
    headerBackgroundColor,
    fontFamily,
    avatarUrl,
    position,
    title,
    customCss,
    width: styleWidth = 380,
    height: styleHeight = 600
  } = effectiveStyle;
  const themeKey = themeKeyRaw || initialTheme || \"light\";
  const themeConfig = {
    light: {
      backgroundColor: \"#ffffff\",
      headerBackground: \"#f5f5f5\",
      textColor: \"#000000\",
      borderColor: \"#dddddd\",
      inputBg: \"#ffffff\",
      inputText: \"#000000\",
      inputBorder: \"#dddddd\",
      buttonBg: primaryColor,
      buttonColor: \"#ffffff\"
    },
    dark: {
      backgroundColor: \"#1e1e1e\",
      headerBackground: \"#2a2a2a\",
      textColor: \"#ffffff\",
      borderColor: \"#444444\",
      inputBg: \"#2a2a2a\",
      inputText: \"#ffffff\",
      inputBorder: \"#444444\",
      buttonBg: primaryColor,
      buttonColor: \"#000000\"
    },
    custom: {
      backgroundColor: primaryColor.toLowerCase() === secondaryColor.toLowerCase() ? fallbackBgColor : secondaryColor,
      headerBackground: headerBackgroundColor?.trim() || secondaryColor,
      textColor: primaryColor.toLowerCase() === secondaryColor.toLowerCase() ? fallbackTextColor : primaryColor,
      borderColor: secondaryColor,
      inputBg: primaryColor.toLowerCase() === secondaryColor.toLowerCase() ? fallbackBgColor : secondaryColor,
      inputText: primaryColor.toLowerCase() === secondaryColor.toLowerCase() ? fallbackTextColor : primaryColor,
      inputBorder: secondaryColor,
      buttonBg: primaryColor,
      buttonColor: secondaryColor.toLowerCase() === \"#ffffff\" || secondaryColor.toLowerCase() === \"#fff\" ? \"#000000\" : \"#ffffff\"
    }
  };
  const themeDefaults = themeConfig[themeKey] || themeConfig.light;
  const headerBackground = headerBackgroundColor?.trim() ? headerBackgroundColor : themeDefaults.headerBackground;
  const backgroundColor = themeDefaults.backgroundColor;
  const textColor = themeDefaults.textColor;
  const inputBg = themeDefaults.inputBg;
  const inputText = themeDefaults.inputText;
  const inputBorder = themeDefaults.inputBorder;

  // Estados React
  const [message, setMessage] = (0,react__WEBPACK_IMPORTED_MODULE_7__.useState)(\"\");
  const debugSetMessages = newMessages => {
    setMessages(newMessages);
  };
  const [previewImageUrl, setPreviewImageUrl] = (0,react__WEBPACK_IMPORTED_MODULE_7__.useState)(null);
  const [isImageModalOpen, setIsImageModalOpen] = (0,react__WEBPACK_IMPORTED_MODULE_7__.useState)(false);
  const [isMobileLocked, setIsMobileLocked] = (0,react__WEBPACK_IMPORTED_MODULE_7__.useState)(false);
  const [imageGroup, setImageGroup] = (0,react__WEBPACK_IMPORTED_MODULE_7__.useState)([]);
  const [imageGroupBlobUrls, setImageGroupBlobUrls] = (0,react__WEBPACK_IMPORTED_MODULE_7__.useState)({});
  const [activeImageIndex, setActiveImageIndex] = (0,react__WEBPACK_IMPORTED_MODULE_7__.useState)(0);
  const [isTyping, setIsTyping] = (0,react__WEBPACK_IMPORTED_MODULE_7__.useState)(false);
  // Eliminado: declaraciÃ³n duplicada de conversationId/setConversationId
  const messagesEndRef = (0,react__WEBPACK_IMPORTED_MODULE_7__.useRef)(null);
  const [iaWarning, setIaWarning] = (0,react__WEBPACK_IMPORTED_MODULE_7__.useState)(null);
  const textareaRef = (0,react__WEBPACK_IMPORTED_MODULE_7__.useRef)(null);
  const [typingSender, setTypingSender] = (0,react__WEBPACK_IMPORTED_MODULE_7__.useState)(null);

  // Safeguard to turn off typing indicator if bot is not ready, disconnected, or has a warning
  (0,react__WEBPACK_IMPORTED_MODULE_7__.useEffect)(() => {
    if ((!isBotReady || !isConnected || iaWarning) && isTyping) {
      setIsTyping(false);
      setTypingSender(null);
    }
  }, [isBotReady, isConnected, iaWarning, isTyping]);

  // CachÃ© vÃ¡lido por 3.5 minutos (sincronizado con INACTIVITY_TIMEOUT + advertencia)
  const CACHE_TIMEOUT = 3.5 * 60 * 1000; // 210 segundos

  // âœ… VALIDAR conversaciÃ³n en cachÃ© antes de cargarla
  // Si estÃ¡ expirada/cerrada, limpiar y empezar nueva
  (0,react__WEBPACK_IMPORTED_MODULE_7__.useEffect)(() => {
    // En mÃ³vil, no cargar cachÃ© - sesiÃ³n limpia
    if (isMobileView) {
      return;
    }

    // Si hay propConversationId (desde QR o URL), el historial vendrÃ¡ del servidor
    if (propConversationId) {
      return;
    }
    const validateAndLoadCache = async () => {
      const cached = loadConversationCache();
      if (!cached || !cached.conversationId) {
        return;
      }

      // ðŸ” VALIDAR: Verificar si la conversaciÃ³n sigue activa
      try {
        const response = await fetch(`${config_environment__WEBPACK_IMPORTED_MODULE_10__.API_URL}/Conversations/${cached.conversationId}/status`, {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json'
          },
          credentials: 'include'
        });
        if (!response.ok) {
          // Si no existe (404) o error, limpiar cachÃ©
          clearCache();
          sessionStorage.removeItem(CACHE_KEY);
          localStorage.removeItem(CACHE_KEY);
          return;
        }
        const status = await response.json();

        // âŒ Si estÃ¡ cerrada o expirada, limpiar cachÃ© inmediatamente
        if (status.Status === 'closed' || status.Status === 'expired') {
          console.warn(`[CACHE] âŒ ConversaciÃ³n ${cached.conversationId} estÃ¡ ${status.Status}. Limpiando cachÃ©...`);
          clearCache();
          sessionStorage.removeItem(CACHE_KEY);
          localStorage.removeItem(CACHE_KEY);
          setConversationId(null);
          conversationIdRef.current = null;
          setQrUrl(\"\");
          setMessages([]);
          setPromptSent(false);
          promptSentRef.current = false;
          return;
        }

        // âœ… ConversaciÃ³n vÃ¡lida, cargar desde cachÃ©
        setConversationId(cached.conversationId);
        const unifiedMessages = (0,_utils_chatUtils__WEBPACK_IMPORTED_MODULE_0__.unifyMessages)(cached.messages.map(_utils_chatUtils__WEBPACK_IMPORTED_MODULE_0__.normalizeMessage));
        setMessages(unifiedMessages);
        if (unifiedMessages.some(m => m.from === \"user\")) {
          setPromptSent(true);
          promptSentRef.current = true;
        }
      } catch (error) {
        console.error('[CACHE] Error validando conversaciÃ³n:', error);
        // ðŸ”´ NO limpiar cachÃ© en error de red - preservar mensajes para que no quede en blanco al recargar
        // Solo limpiamos cuando tenemos respuesta exitosa que dice closed/expired
        if (cached?.conversationId && cached?.messages?.length) {
          setConversationId(cached.conversationId);
          const unifiedMessages = (0,_utils_chatUtils__WEBPACK_IMPORTED_MODULE_0__.unifyMessages)(cached.messages.map(_utils_chatUtils__WEBPACK_IMPORTED_MODULE_0__.normalizeMessage));
          setMessages(unifiedMessages);
          if (unifiedMessages.some(m => m.from === \"user\")) {
            setPromptSent(true);
            promptSentRef.current = true;
          }
        }
      }
    };
    validateAndLoadCache();
  }, [isMobileView, propConversationId]);

  // ðŸŽ¯ NOTA: Carga de historial QR ahora ocurre EN initConnection para evitar race conditions
  // Mantenemos este useEffect solo como respaldo para casos edge
  (0,react__WEBPACK_IMPORTED_MODULE_7__.useEffect)(() => {
    if (!propConversationId || !isMobileView) {
      return;
    }

    // Si ya se cargÃ³ en initConnection, no hacer nada
    if (qrHistoryLoadedRef.current) {
      return;
    }
    const loadHistoryFromQR = async () => {
      try {
        const response = await (0,services_conversationsService__WEBPACK_IMPORTED_MODULE_21__.getConversationHistory)(propConversationId);

        // El backend devuelve: { conversationDetails, history: [...], debug: {...} }
        const historyArray = response?.history || [];
        if (historyArray && Array.isArray(historyArray) && historyArray.length > 0) {
          // ðŸ” DEDUPLICACIÃ“N: Eliminar mensajes de archivo duplicados
          // PatrÃ³n detectado: Backend devuelve ID 420 (/uploads/...) y ID 421 (/api/files/chat/420)
          // SoluciÃ³n: Eliminar mensajes donde URL contiene referencia a un ID que ya existe como mensaje
          const fileMessagesById = new Map();
          const deduplicatedHistory = [];
          for (const item of historyArray) {
            if (item.type === 'file' || item.type === 'image') {
              const url = item.url || item.fileUrl || '';

              // Detectar si es referencia indirecta (e.g., /api/files/chat/420)
              const isIndirectRef = url.match(/\\/api\\/files\\/chat\\/(\\d+)/);
              if (isIndirectRef) {
                const refId = parseInt(isIndirectRef[1]);
                if (fileMessagesById.has(refId)) {
                  // Este es un duplicado - es referencia a un archivo que ya tenemos
                  continue; // Skip this item
                }
              }
              fileMessagesById.set(item.id, item);
            }
            deduplicatedHistory.push(item);
          }
          if (deduplicatedHistory.length < historyArray.length) {}

          // ðŸ†• Agrupar archivos/imÃ¡genes consecutivas del mismo usuario
          const groupedHistory = (0,_utils_chatUtils__WEBPACK_IMPORTED_MODULE_0__.groupConsecutiveFiles)(deduplicatedHistory);

          // Normalizar mensajes del historial
          const historyMessages = groupedHistory.map(msg => {
            // El backend devuelve: { id, type, text, timestamp, fromRole, fromId, fromName, fromAvatarUrl, ... }
            // CorrecciÃ³n: Forzar 'from' a 'bot' si el mensaje es del bot en historial mÃ³vil
            let fromValue = msg.fromRole;
            if (isMobileView && (msg.fromRole === 'bot' || msg.fromName?.toLowerCase() === 'bot')) {
              fromValue = 'bot';
            }
            const normalized = (0,_utils_chatUtils__WEBPACK_IMPORTED_MODULE_0__.normalizeMessage)({
              id: msg.id,
              type: msg.type,
              ...(!msg.isGroupedFile && {
                text: msg.text
              }),
              content: msg.text,
              from: fromValue,
              sender: fromValue,
              timestamp: msg.timestamp,
              fromName: msg.fromName,
              fromAvatarUrl: msg.fromAvatarUrl,
              ...(msg.isGroupedFile && {
                isGroupedFile: true,
                files: msg.files
              }),
              ...(!msg.isGroupedFile && (msg.type === 'file' || msg.type === 'image') && {
                fileUrl: msg.fileUrl,
                fileName: msg.fileName,
                fileType: msg.fileType
              })
            });
            const final = {
              ...normalized,
              status: 'sent',
              // Los mensajes histÃ³ricos siempre tienen estado 'sent'
              color: normalized.color || (0,_utils_colors__WEBPACK_IMPORTED_MODULE_23__.getSenderColor)(normalized.from)
            };
            return final;
          });

          // ðŸ”¹ Deduplicar archivos dentro de cada mensaje por ID, nombre y tamaÃ±o (mÃ¡s robusto)
          const messagesWithUniqueFiles = historyMessages.map(msg => {
            if (msg.isGroupedFile && msg.multipleFiles?.length > 0) {
              const seenFiles = new Set();
              const uniqueFiles = [];
              for (const file of msg.multipleFiles) {
                // Usar combinaciÃ³n de nombre y tamaÃ±o si existe, si no solo nombre
                const fileKey = `${file.fileName || ''}|${file.size || ''}`;
                if (!seenFiles.has(fileKey)) {
                  seenFiles.add(fileKey);
                  uniqueFiles.push(file);
                } else {
                  console.warn(`âš ï¸ [loadHistoryFromQR] Eliminando duplicado - archivo: ${file.fileName}`);
                }
              }
              return {
                ...msg,
                multipleFiles: uniqueFiles
              };
            }
            return msg;
          });

          // Eliminar duplicados de MENSAJES por uniqueKey
          const deduped = new Map();
          for (const msg of messagesWithUniqueFiles) {
            const key = msg.uniqueKey;

            // Solo agregar si no existe la clave
            if (!deduped.has(key)) {
              deduped.set(key, msg);
            }
          }
          const uniqueMessages = Array.from(deduped.values());
          setMessages(uniqueMessages);
          // --- OPTIMISTIC UI PARA ENVÃO DE ARCHIVOS/IMÃGENES DESDE MÃ“VIL ---
          // Busca la funciÃ³n que maneja el envÃ­o de archivos desde el mÃ³vil (ejemplo: sendFile o sendDocument)
          // AquÃ­ se muestra un ejemplo genÃ©rico, debes adaptar el nombre de la funciÃ³n si es diferente:

          // function sendFile(file) {
          //   const tempId = uuidv4();
          //   const userFileMessage = normalizeMessage({
          //     tempId,
          //     from: \"user\",
          //     file: {
          //       fileName: file.name,
          //       fileType: file.type,
          //       fileUrl: file.previewUrl || '',
          //       size: file.size
          //     },
          //     status: \"sending\",
          //     timestamp: new Date().toISOString()
          //   });
          //   setMessages(prev => [...prev, userFileMessage]);
          //   // ...lÃ³gica para subir el archivo y luego actualizar el estado cuando llegue la confirmaciÃ³n del backend
          // }

          // IMPORTANTE: AsegÃºrate de que la funciÃ³n que maneja el envÃ­o de archivos desde mÃ³vil incluya este bloque para agregar el mensaje localmente.

          // ðŸ†• Marcar que se cargÃ³ exitosamente
          qrHistoryLoadedRef.current = true;

          // ðŸ”¹ Marcar que ya se mostrÃ³ bienvenida (porque estÃ¡ en el historial)
          welcomeShownRef.current = true;
          if (uniqueMessages.some(m => m.from === \"user\")) {
            setPromptSent(true);
            promptSentRef.current = true;
          }
        } else {
          // ðŸ†• Marcar que se intentÃ³ cargar (para no intentar de nuevo)
          qrHistoryLoadedRef.current = true;
          // ðŸ”¹ Marcar que ya se intentÃ³ cargar (para que no intente mostrar bienvenida de nuevo)
          welcomeShownRef.current = false; // Permitir mostrar bienvenida en historial vacÃ­o
        }
      } catch (error) {
        // ðŸ”´ MANEJO DE ERRORES HTTP: 410 (Expirada), 404 (No existe), 403 (Acceso denegado)
        const status = error?.response?.status;
        const errorMessage = error?.response?.data?.error || error?.message;

        // ðŸ†• Marcar que se intentÃ³ cargar (aunque fallÃ³, para no intentar infinitas veces)
        qrHistoryLoadedRef.current = true;

        // Determinar mensaje segÃºn cÃ³digo de error
        let userMessage = \"Error al cargar la conversaciÃ³n\";
        if (status === 410) {
          // 410 Gone: ConversaciÃ³n expirada
          userMessage = \"La conversaciÃ³n ha expirado. Por favor, escanea un nuevo cÃ³digo QR.\";
        } else if (status === 404) {
          // 404 Not Found: ConversaciÃ³n no existe
          userMessage = \"La conversaciÃ³n no existe o fue eliminada.\";
        } else if (status === 403) {
          // 403 Forbidden: Acceso denegado
          userMessage = \"Acceso denegado a esta conversaciÃ³n.\";
        } else if (status === 401) {
          // 401 Unauthorized: Sin autenticaciÃ³n
          userMessage = \"SesiÃ³n expirada. Por favor, intenta de nuevo.\";
        }

        // Mostrar alerta al usuario
        alert(`âš ï¸ ${userMessage}`);

        // Limpiar cachÃ© y cerrar widget
        clearCache();

        // Cerrar widget y resetear estado
        setIsOpen(false);
        setConversationId(null);
        conversationIdRef.current = null;
        setQrUrl(\"\");
        setMessages([]);
        setPromptSent(false);
        promptSentRef.current = false;
      }
    };
    if (propConversationId && isMobileView) {
      loadHistoryFromQR();
    }
  }, [propConversationId, isMobileView]);

  // âŒ ELIMINADO: setInterval que limpiaba cachÃ© en tiempo real
  // El cachÃ© ahora SOLO se limpia cuando cierra por INACTIVIDAD
  // Esto evita que se cree conversaciÃ³n nueva mientras el widget estÃ¡ abierto

  // âœ… LÃ³gica de guardado de cachÃ© que se activa con cada cambio de mensajes.
  (0,react__WEBPACK_IMPORTED_MODULE_7__.useEffect)(() => {
    if (conversationId && messages.length > 0) {
      // Solo guardar en cachÃ© si hay conversaciÃ³n activa y mensajes
      if (conversationId && messages.length > 0) {
        saveConversationCache(conversationId, messages);
      }
    }
  }, [messages, conversationId]);

  // ðŸ”´ Ref para rastrear si fue una transiciÃ³n de abierto a cerrado
  const wasOpenRef = (0,react__WEBPACK_IMPORTED_MODULE_7__.useRef)(false);

  // ðŸ”´ SISTEMA DE INACTIVIDAD TRAS CIERRE MANUAL (diferente del sistema de widget abierto)
  // Cuando usuario cierra con X: espera 3 min antes de limpiar (permite reabrir y recuperar conversaciÃ³n)
  const MANUAL_CLOSE_INACTIVITY_TIMEOUT = 3 * 60 * 1000; // 3 minutos igual que widget abierto

  (0,react__WEBPACK_IMPORTED_MODULE_7__.useEffect)(() => {
    // Solo en web, no en mÃ³vil
    if (isMobileView) {
      wasOpenRef.current = isOpen;
      return;
    }

    // ðŸ”´ No iniciar timer de cierre manual si sesiÃ³n mÃ³vil estÃ¡ activa
    if (isMobileSessionActive) {
      wasOpenRef.current = isOpen;
      return;
    }

    // Detectar transiciÃ³n: widget estaba abierto y ahora estÃ¡ cerrado
    const wasOpenBefore = wasOpenRef.current;
    wasOpenRef.current = isOpen;
    if (wasOpenBefore && !isOpen && (conversationId || messages.length > 0)) {
      // âœ… Widget cerrado manualmente - INICIAR timer de inactividad para limpieza diferida
      const now = Date.now();
      const inactivityInfo = {
        closedAt: now,
        conversationId: conversationIdRef.current,
        timeout: MANUAL_CLOSE_INACTIVITY_TIMEOUT
      };
      localStorage.setItem('chat_inactivity_info', JSON.stringify(inactivityInfo));
      sessionStorage.setItem('chat_inactivity_info', JSON.stringify(inactivityInfo));

      // Limpiar interval anterior si existe
      if (window.__manualCloseIntervalId) {
        clearInterval(window.__manualCloseIntervalId);
      }

      // Polling cada 5 segundos para verificar si pasaron los 3 minutos
      window.__manualCloseIntervalId = setInterval(async () => {
        const info = JSON.parse(localStorage.getItem('chat_inactivity_info') || '{}');
        if (!info.closedAt) {
          // Info fue limpiada (widget reabierto), cancelar polling
          clearInterval(window.__manualCloseIntervalId);
          window.__manualCloseIntervalId = null;
          return;
        }
        const elapsed = Date.now() - info.closedAt;
        const remainingSeconds = Math.max(0, (MANUAL_CLOSE_INACTIVITY_TIMEOUT - elapsed) / 1000);

        // Si pasaron los 3 minutos, ejecutar limpieza
        if (elapsed >= MANUAL_CLOSE_INACTIVITY_TIMEOUT) {
          clearInterval(window.__manualCloseIntervalId);
          window.__manualCloseIntervalId = null;
          const currentlyOpen = wasOpenRef.current;
          const elapsedMinutes = (elapsed / 60000).toFixed(1);

          // Solo limpiar si el widget SIGUE CERRADO
          if (!currentlyOpen) {
            // âœ… PASO 1: Notificar al backend que conversaciÃ³n expirÃ³
            if (info.conversationId) {
              try {
                // Intentar con SignalR primero si estÃ¡ conectado
                if (connectionRef.current && connectionRef.current.state === \"Connected\") {
                  await connectionRef.current.invoke(\"NotifyWidgetExpired\", info.conversationId);
                } else {
                  // Si SignalR no estÃ¡ disponible, usar API REST directamente
                  const response = await fetch(`http://localhost:5006/api/Conversations/${info.conversationId}/expire`, {
                    method: 'POST',
                    headers: {
                      'Content-Type': 'application/json'
                    }
                  });
                  if (response.ok) {
                    console.log(`[LOG][MANUAL_CLOSE][${new Date().toISOString()}] âœ… Backend notificado vÃ­a REST API`);
                  } else {
                    console.error(`[LOG][MANUAL_CLOSE][${new Date().toISOString()}] âŒ Error en REST API: ${response.status}`);
                  }
                }
              } catch (err) {
                console.error(`[LOG][MANUAL_CLOSE][${new Date().toISOString()}] âŒ Error notificando backend:`, err);
              }
            } else {
              console.log(`[LOG][MANUAL_CLOSE][${new Date().toISOString()}] âš ï¸ No hay conversationId para notificar`);
            }

            // âœ… PASO 2: Limpiar storage y estado
            clearCache();
            sessionStorage.removeItem(CACHE_KEY);
            localStorage.removeItem(CACHE_KEY);
            sessionStorage.removeItem('chat_inactivity_info');
            localStorage.removeItem('chat_inactivity_info');

            // Solo limpiar estado en memoria si el widget sigue cerrado
            setConversationId(null);
            conversationIdRef.current = null;
            setQrUrl(\"\");
            setMessages([]);
            setPromptSent(false);
            promptSentRef.current = false;
            welcomeShownRef.current = false;
            loadedConversationsRef.current = new Set();
          } else {
            sessionStorage.removeItem('chat_inactivity_info');
            localStorage.removeItem('chat_inactivity_info');
          }
        }
      }, 5000); // Verificar cada 5 segundos
    } else if (isOpen && !wasOpenBefore) {
      // âœ… Widget REABIERTO - cancelar polling de limpieza si existe
      if (window.__manualCloseIntervalId) {
        clearInterval(window.__manualCloseIntervalId);
        window.__manualCloseIntervalId = null;

        // Limpiar info de inactividad
        const info = JSON.parse(localStorage.getItem('chat_inactivity_info') || '{}');
        if (info.closedAt) {
          const elapsedSeconds = ((Date.now() - info.closedAt) / 1000).toFixed(1);
        }
        sessionStorage.removeItem('chat_inactivity_info');
        localStorage.removeItem('chat_inactivity_info');
      }
    }
    return () => {
      if (window.__manualCloseIntervalId) {
        clearInterval(window.__manualCloseIntervalId);
        window.__manualCloseIntervalId = null;
      }
    };
  }, [isMobileView, isOpen, isMobileSessionActive]);
  const messageRefs = (0,react__WEBPACK_IMPORTED_MODULE_7__.useRef)([]);
  messageRefs.current = messages.map((_, i) => messageRefs.current[i] ?? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_7___default().createRef());
  const typingRef = (0,react__WEBPACK_IMPORTED_MODULE_7__.useRef)(null);
  const pendingFileMessageRef = (0,react__WEBPACK_IMPORTED_MODULE_7__.useRef)(null);
  const pendingReceiveQueueRef = (0,react__WEBPACK_IMPORTED_MODULE_7__.useRef)([]);
  const flushScheduledRef = (0,react__WEBPACK_IMPORTED_MODULE_7__.useRef)(false);

  // El overlay debe bloquear toda la UI cuando la sesiÃ³n mÃ³vil estÃ¡ activa
  let showDeviceConflictOverlay = false;
  if (typeof isBlockedByOtherDevice !== 'undefined' && typeof isMobileView !== 'undefined') {
    showDeviceConflictOverlay = isBlockedByOtherDevice && !isMobileView;
  }
  (0,react__WEBPACK_IMPORTED_MODULE_7__.useEffect)(() => {
    // (Eliminado log de renderizado DeviceConflictOverlay)
  }, [showDeviceConflictOverlay]);
  (0,react__WEBPACK_IMPORTED_MODULE_7__.useEffect)(() => {
    if (!isOpen || isDemo) {
      if (connectionRef.current) {
        connectionRef.current.stop();
        connectionRef.current = null;
      }
      return;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // TIEMPO REAL: Solo mensajes nuevos vÃ­a SignalR. NO mezclar con historial.
    // Historial se carga aparte (cache, getConversationHistory).
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const handleReceiveMessage = msg => {
      const newMessage = (0,_utils_chatUtils__WEBPACK_IMPORTED_MODULE_0__.normalizeMessage)(msg);
      if (!newMessage.color) newMessage.color = (0,_utils_colors__WEBPACK_IMPORTED_MODULE_23__.getSenderColor)(newMessage.from);
      // âœ… Skip welcome message if it matches the locally sent one
      if (newMessage.from === \"bot\" && lastWelcomeTextRef.current && newMessage.text === lastWelcomeTextRef.current) {
        console.log('[LOG][MESSAGE][ReceiveMessage] Saltando mensaje de bienvenida duplicado');
        lastWelcomeTextRef.current = null;
        return;
      }
      setTypingSender(currentTypingSender => {
        if (currentTypingSender && currentTypingSender === newMessage.from) {
          setIsTyping(false);
          return null;
        }
        return currentTypingSender;
      });
      const flushPending = () => {
        if (pendingReceiveQueueRef.current.length === 0) return;
        const toAdd = pendingReceiveQueueRef.current.splice(0);
        flushScheduledRef.current = false;
        setMessages(prev => [...prev, ...toAdd]); // AÃ±adir a mensajes actuales (historial + tiempo real)
      };
      setMessages(prev => {
        // 1. Si llega con tempId, actualiza el mensaje local
        if (newMessage.tempId) {
          const existingMessageIndex = prev.findIndex(m => m.tempId === newMessage.tempId && m.status === 'sending');
          if (existingMessageIndex !== -1) {
            const updatedMessages = [...prev];
            updatedMessages[existingMessageIndex] = {
              ...updatedMessages[existingMessageIndex],
              ...newMessage,
              status: newMessage.status || 'sent'
            };
            // (Eliminado log de mensaje actualizado tempId)
            return updatedMessages;
          }
        }
        // 2. Si llega mensaje del usuario con estado 'queued', busca por texto y estado 'sent' o 'sending'
        if (newMessage.from === 'user' && newMessage.status === 'queued') {
          const idx = prev.findIndex(m => m.from === 'user' && m.text === newMessage.text && (m.status === 'sent' || m.status === 'sending'));
          if (idx !== -1) {
            const updatedMessages = [...prev];
            updatedMessages[idx] = {
              ...updatedMessages[idx],
              ...newMessage,
              status: 'queued',
              id: newMessage.id // actualiza el id si es nuevo
            };
            // (Eliminado log de mensaje usuario actualizado queued)
            return updatedMessages;
          }
        }
        // 3. Si ya existe por id (solo cuando id es vÃ¡lido; id vacÃ­o viene del servidor para archivos, varios pueden tenerlo)
        if (newMessage.id && prev.some(m => m.id === newMessage.id)) return prev;
        // 4. Mensaje de archivo del usuario: si ya mostramos optimista con mismo fileUrl, actualizar; si no, aÃ±adir (reconexiÃ³n).
        const files = newMessage.multipleFiles || newMessage.files || [];
        const firstFileUrl = files[0]?.fileUrl ?? files[0]?.filePath ?? files[0]?.url;
        const fileUrlForKey = url => {
          if (!url || typeof url !== \"string\") return \"\";
          try {
            if (url.startsWith(\"http\")) return new URL(url).pathname;
            return (url.split(\"?\")[0] || \"\").trim();
          } catch (e) {
            return (url || \"\").trim();
          }
        };
        const newKey = fileUrlForKey(firstFileUrl);
        const isUserFileOnly = newMessage.from === \"user\" && (firstFileUrl || files.length > 0 && !newMessage.text?.trim());
        if (isUserFileOnly) {
          // CondiciÃ³n 4: Mensaje de archivo. AÃ±adir siempre; la deduplicaciÃ³n agresiva impedÃ­a ver la 2Âª imagen.
          // Si el backend envÃ­a el mismo archivo 2 veces, se verÃ¡ duplicado (se puede ajustar despuÃ©s).
          pendingFileMessageRef.current = null;
          const newFiles = newMessage.multipleFiles || [];
          const mergedFiles = newFiles.length ? newFiles.map((nf, i) => ({
            ...nf,
            fileContent: nf.fileContent ?? prev[prev.length - 1]?.multipleFiles?.[i]?.fileContent ?? nf.fileContent,
            preview: nf.preview ?? prev[prev.length - 1]?.multipleFiles?.[i]?.preview ?? nf.preview
          })) : newFiles;
          const toAdd = {
            ...newMessage,
            status: \"sent\",
            multipleFiles: mergedFiles,
            uniqueKey: newMessage.uniqueKey || `file-${(0,uuid__WEBPACK_IMPORTED_MODULE_8__[\"default\"])()}` // Siempre Ãºnico para evitar colisiÃ³n con mensajes simultÃ¡neos
          };
          pendingReceiveQueueRef.current.push(toAdd);
          if (!flushScheduledRef.current) {
            flushScheduledRef.current = true;
            queueMicrotask(flushPending);
          }
          return prev;
        }
        pendingReceiveQueueRef.current.push(newMessage);
        if (!flushScheduledRef.current) {
          flushScheduledRef.current = true;
          queueMicrotask(flushPending);
        }
        return prev;
      });
    };

    // âœ… Define handlers OUTSIDE initConnection so they're accessible to cleanup
    const handleMessageQueued = data => {
      console.log('ðŸ“¬ [SignalR] MessageQueued recibido:', data);
      if (data.tempId) {
        setMessages(prev => prev.map(m => m.tempId === data.tempId ? {
          ...m,
          status: 'queued',
          id: data.messageId
        } : m));
      }
    };
    const handleMobileSessionEnded = async data => {
      console.log('ðŸ”´ [SignalR] MobileSessionEnded recibido:', data);
      try {
        // Limpiar todo cuando mÃ³vil cierra
        clearCache();
        sessionStorage.removeItem(CACHE_KEY);
        localStorage.removeItem(CACHE_KEY);
        setConversationId(null);
        conversationIdRef.current = null;
        setMessages([]);
        setPromptSent(false);
        promptSentRef.current = false;
        welcomeShownRef.current = false;
        loadedConversationsRef.current = new Set();
        setIsOpen(false);
        console.log(`âœ… [MobileSessionEnded] Widget limpiado tras cierre de mÃ³vil`);
      } catch (e) {
        console.error('âŒ [MobileSessionEnded] Error al limpiar:', e);
      }
    };
    let connection;
    const initConnection = async () => {
      try {
        // Usar el valor correcto de token (widget o admin)
        const widgetToken = propWidgetToken;
        const explicitToken = propWidgetClientSecret || widgetToken;

        // âœ… Prioridades para determinar quÃ© conversationId usar:
        // 1ï¸âƒ£ Si viene desde QR (propConversationId) â†’ USAR ESE EXACTAMENTE
        // 2ï¸âƒ£ Si ya existe conversaciÃ³n en ref (reapertura) â†’ USAR ESE
        // 3ï¸âƒ£ Si hay en cachÃ© Y NO FUE CERRADO EXPLÃCITAMENTE â†’ USAR ESE
        // 4ï¸âƒ£ Crear nueva conversaciÃ³n

        let convId = propConversationId;
        if (!convId) {
          convId = conversationIdRef.current;
        }
        if (!convId) {
          // ðŸ”´ MÃ“VIL: NUNCA crear conversaciÃ³n. Solo unirse a conversaciones vigentes desde QR
          if (isMobileView) {
            throw new Error(\"En modo mÃ³vil no se pueden crear conversaciones. Solo se permite acceder a conversaciones vigentes desde el QR.\");
          }
          // â•â•â• HISTORIAL: Cargar desde cachÃ© (al recargar) â•â•â•
          const cached = loadConversationCache();
          if (cached && cached.conversationId) {
            convId = cached.conversationId;
            console.log(`[LOG][CACHE][${new Date().toISOString()}] ðŸ”„ Recuperando conversaciÃ³n del cachÃ©: ${convId}`);
            console.log(`[LOG][CACHE][${new Date().toISOString()}] ðŸ’¬ Mensajes recuperados: ${cached.messages?.length || 0}`);

            // Dedupe solo DENTRO del cachÃ©: mismo archivo guardado 2 veces por bug. No afecta tiempo real.
            if (cached.messages && Array.isArray(cached.messages) && cached.messages.length > 0) {
              const fileUrlKey = m => {
                const url = m?.multipleFiles?.[0]?.fileUrl ?? m?.file?.fileUrl ?? m?.multipleFiles?.[0]?.filePath ?? m?.file?.filePath;
                if (!url || typeof url !== \"string\") return \"\";
                try {
                  return url.startsWith(\"http\") ? new URL(url).pathname : (url.split(\"?\")[0] || \"\").trim();
                } catch (e) {
                  return (url || \"\").trim();
                }
              };
              const seenFileKeys = new Set();
              const deduped = cached.messages.filter(m => {
                if (m.from !== \"user\" || !m.multipleFiles?.length && !m.file) return true;
                const key = fileUrlKey(m.multipleFiles?.[0] || m.file);
                if (seenFileKeys.has(key)) return false;
                seenFileKeys.add(key);
                return true;
              });
              setMessages(deduped);
              setPromptSent(true);
              promptSentRef.current = true;

              // âœ… DETECTAR SI HAY UN MENSAJE DEL USUARIO SIN RESPUESTA
              const lastMessage = deduped[deduped.length - 1];
              const secondLastMessage = deduped.length > 1 ? deduped[deduped.length - 2] : null;

              // Verificar si el Ãºltimo mensaje es del usuario Y no hay respuesta del bot despuÃ©s
              const isLastMessageFromUser = lastMessage && lastMessage.from === 'user';
              const hasNoResponse = !secondLastMessage || secondLastMessage.from === 'user'; // No hay msg previo o tambiÃ©n es del usuario

              if (isLastMessageFromUser && hasNoResponse) {
                const isFileOnly = !lastMessage.text?.trim() && (lastMessage.multipleFiles?.length > 0 || lastMessage.file);
                if (!isFileOnly) {
                  console.log(`[LOG][CACHE][${new Date().toISOString()}] âš ï¸ Detectado mensaje sin respuesta`);
                  console.log(`[LOG][CACHE][${new Date().toISOString()}] ðŸ“¤ Mensaje pendiente: \"${lastMessage.text}\"`);
                  console.log(`[LOG][CACHE][${new Date().toISOString()}] ðŸ¤– Se verificarÃ¡ si el bot estÃ¡ activo para reenviar`);
                  window.__pendingMessageRetry = {
                    conversationId: convId,
                    message: lastMessage.text,
                    tempId: lastMessage.tempId || lastMessage.id,
                    timestamp: new Date().toISOString(),
                    botId: botId
                  };
                } else {
                  console.log(`[LOG][CACHE][${new Date().toISOString()}] ðŸ“Ž Ãšltimo mensaje es solo archivo - no se reenvÃ­a por SendMessage`);
                }
              } else {
                console.log(`[LOG][CACHE][${new Date().toISOString()}] âœ… Historial completo - no se requiere reenvÃ­o`);
                if (isLastMessageFromUser) {
                  console.log(`[LOG][CACHE][${new Date().toISOString()}] ðŸ“ Ãšltimo mensaje del usuario YA tiene respuesta del bot`);
                }
              }
            }
          }
          if (!convId) {
            console.warn('[CACHE] No se encontrÃ³ cachÃ© vÃ¡lido, se crearÃ¡ nueva conversaciÃ³n.');
            convId = await (0,services_chatService__WEBPACK_IMPORTED_MODULE_20__.createConversation)(userId, botId, propWidgetClientSecret, true); // âœ… Pasar clientSecret
          }
        }
        if (!convId) throw new Error(\"No se recibiÃ³ conversationId\");

        // âœ… CRÃTICO: Convertir a nÃºmero (puede venir como string de query params)
        const convIdNum = typeof convId === 'string' ? parseInt(convId, 10) : convId;
        if (isNaN(convIdNum) || convIdNum <= 0) {
          throw new Error(`conversationId invÃ¡lido: ${convId}`);
        }
        conversationIdRef.current = convIdNum;
        setConversationId(convIdNum);

        // âœ… Crear conexiÃ³n SignalR con (conversationId, token) para que la URL y JoinRoom sean correctos
        connection = (0,services_signalr__WEBPACK_IMPORTED_MODULE_11__.createHubConnection)(convIdNum, explicitToken);
        connectionRef.current = connection;

        // ðŸ†• EN MÃ“VIL: Cargar historial AQUÃ para evitar race conditions
        if (isMobileView && propConversationId && !qrHistoryLoadedRef.current) {
          try {
            const response = await (0,services_conversationsService__WEBPACK_IMPORTED_MODULE_21__.getConversationHistory)(propConversationId);
            const historyArray = response?.history || [];
            if (historyArray && Array.isArray(historyArray) && historyArray.length > 0) {
              const groupedHistory = (0,_utils_chatUtils__WEBPACK_IMPORTED_MODULE_0__.groupConsecutiveFiles)(historyArray);
              const historyMessages = groupedHistory.map(msg => {
                const normalized = (0,_utils_chatUtils__WEBPACK_IMPORTED_MODULE_0__.normalizeMessage)({
                  id: msg.id,
                  type: msg.type,
                  ...(!msg.isGroupedFile && {
                    text: msg.text
                  }),
                  content: msg.text,
                  from: msg.fromRole,
                  sender: msg.fromRole,
                  timestamp: msg.timestamp,
                  fromName: msg.fromName,
                  fromAvatarUrl: msg.fromAvatarUrl,
                  ...(msg.isGroupedFile && {
                    isGroupedFile: true,
                    files: msg.files
                  }),
                  ...(!msg.isGroupedFile && (msg.type === 'file' || msg.type === 'image') && {
                    fileUrl: msg.fileUrl,
                    fileName: msg.fileName,
                    fileType: msg.fileType
                  })
                });
                return {
                  ...normalized,
                  status: 'sent',
                  color: normalized.color || (0,_utils_colors__WEBPACK_IMPORTED_MODULE_23__.getSenderColor)(normalized.from)
                };
              });
              const uniqueMessages = Array.from(new Map(historyMessages.map(msg => [msg.uniqueKey, msg])).values());
              setMessages(uniqueMessages);
              qrHistoryLoadedRef.current = true;
              welcomeShownRef.current = true;
              if (uniqueMessages.some(m => m.from === \"user\")) {
                setPromptSent(true);
                promptSentRef.current = true;
              }
            } else {
              qrHistoryLoadedRef.current = true;
              welcomeShownRef.current = false;
            }
          } catch (error) {
            qrHistoryLoadedRef.current = true;

            // Manejar errores HTTP
            const status = error?.response?.status;
            let userMessage = \"Error al cargar la conversaciÃ³n\";
            if (status === 410) {
              userMessage = \"La conversaciÃ³n ha expirado. Por favor, escanea un nuevo cÃ³digo QR.\";
            } else if (status === 404) {
              userMessage = \"La conversaciÃ³n no existe o fue eliminada.\";
            } else if (status === 403) {
              userMessage = \"Acceso denegado a esta conversaciÃ³n.\";
            } else if (status === 401) {
              userMessage = \"SesiÃ³n expirada. Por favor, intenta de nuevo.\";
            }
            alert(`âš ï¸ ${userMessage}`);
            try {
              clearCache();
              sessionStorage.removeItem(CACHE_KEY);
              localStorage.removeItem(CACHE_KEY);
              // Limpieza total de refs y estados
              setConversationId(null);
              conversationIdRef.current = null;
              setMessages([]);
              setPromptSent(false);
              promptSentRef.current = false;
              welcomeShownRef.current = false;
              loadedConversationsRef.current = new Set();
            } catch (e) {
              console.log(`[LOG][MANUAL_CLOSE][${new Date().toISOString()}] FallÃ³ al borrar cachÃ©/storage por cierre manual.`, e);
            }
            setIsOpen(false);
            setConversationId(null);
            conversationIdRef.current = null;
            setMessages([]);
            setPromptSent(false);
            promptSentRef.current = false;
          }
        }

        // âœ… CRÃTICO: Unir lÃ³gica de JoinRoom y UserIsActive en una sola llamada
        // Esto asegura que el usuario se una a la sala y se marque como activo en un solo paso
        const joinAndActivate = async convId => {
          try {
            await connection.invoke(\"JoinRoom\", convId);
            await connection.invoke(\"UserIsActive\", convId);
          } catch (err) {
            console.error('âŒ [SignalR] Error al unir y activar usuario:', err);
          }
        };

        // Inicializar conexiÃ³n SOLO si conversationId estÃ¡ definido
        if (convIdNum) {
          // âœ… VERIFICAR ESTADO antes de iniciar conexiÃ³n (prevenir error \"not in Disconnected state\")
          if (connection.state === 'Disconnected') {
            // âœ… Registrar event handlers ANTES de conectar
            // ðŸ‘‰ SignalR JavaScript convierte los nombres de mÃ©todos a minÃºsculas
            connection.on(\"receivemessage\", handleReceiveMessage);
            connection.on(\"messagequeued\", handleMessageQueued);
            connection.on(\"receivetyping\", () => setIsTyping(true));
            connection.on(\"receivestoptyping\", () => setIsTyping(false));

            // ðŸ“± Listeners para sesiÃ³n mÃ³vil
            connection.on(\"mobilesessionstarted\", data => {
              console.log('ðŸ“± [SignalR] MobileSessionStarted recibido:', data);
            });
            connection.on(\"mobilesessionended\", handleMobileSessionEnded);
            connection.on(\"widgetsessionended\", data => {});

            // ðŸ”´ CRÃTICO: Registrar handlers de reconexiÃ³n AQUÃ para asegurar que se ejecuten
            connection.onreconnecting(() => {
              console.warn('âš ï¸  [SignalR] Reconectando...');
              setConnectionStatus(\"reconectando...\");
              setIsConnected(false); // Deshabilitar envÃ­o durante reconexiÃ³n
            });
            connection.onreconnected(async () => {
              console.log('âœ… [SignalR] Reconectado exitosamente');
              setConnectionStatus(\"conectado\");

              // ðŸ”„ Re-unirse al grupo despuÃ©s de reconectar
              const reconnectConvId = conversationIdRef.current;
              if (reconnectConvId && connection && connection.state === 'Connected') {
                try {
                  await connection.invoke(\"JoinRoom\", reconnectConvId);
                  await connection.invoke(\"UserIsActive\", reconnectConvId);
                  console.log('âœ… [SignalR] Re-unido al grupo', reconnectConvId, 'despuÃ©s de reconexiÃ³n');
                } catch (err) {
                  console.error('âŒ [SignalR] Error al re-unirse al grupo despuÃ©s de reconexiÃ³n:', err);
                }
              }

              // ðŸ”´ CRÃTICO: Restaurar isConnected DESPUÃ‰S de re-unirse al grupo
              setIsConnected(true);
            });
            connection.onclose(error => {
              console.error('âŒ [SignalR] ConexiÃ³n cerrada', {
                error: error?.message || error,
                connectionState: connection?.state,
                timestamp: new Date().toISOString()
              });
              setConnectionStatus(\"desconectado\");
              setIsConnected(false);
            });

            // Iniciar conexiÃ³n y ESPERAR a que estÃ© Connected
            await connection.start();
            setConnectionStatus(\"conectado\");

            // âœ… ESPERAR 500ms adicionales para asegurar que el backend procesÃ³ la conexiÃ³n
            await new Promise(resolve => setTimeout(resolve, 500));

            // âœ… Ahora sÃ­, unirse a la sala
            await joinAndActivate(convIdNum);

            // âœ… SOLO AHORA habilitar el envÃ­o de mensajes (despuÃ©s de unirse al grupo)
            setIsConnected(true);
          } else if (connection.state === 'Connecting') {
            // Esperar a que termine de conectar
            await new Promise(resolve => {
              const checkInterval = setInterval(() => {
                if (connection.state === 'Connected') {
                  clearInterval(checkInterval);
                  resolve();
                }
              }, 100);
              // Timeout de 10 segundos
              setTimeout(() => {
                clearInterval(checkInterval);
                resolve();
              }, 10000);
            });
            if (connection.state === 'Connected') {
              setConnectionStatus(\"conectado\");
              await joinAndActivate(convIdNum);
              setIsConnected(true);
            }
          } else if (connection.state === 'Connected') {
            setConnectionStatus(\"conectado\");
            await joinAndActivate(convIdNum);
            console.log(`âœ… [SignalR] Usuario unido al grupo ${convIdNum}, habilitando envÃ­o de mensajes`);
            setIsConnected(true);
          } else {
            console.warn(`âš ï¸ [SignalR] Estado inesperado: ${connection.state}`);
          }

          // âœ… REENVIAR MENSAJE PENDIENTE SI EXISTE (solo mensajes de texto; no reenviar archivos)
          setTimeout(async () => {
            if (!window.__pendingMessageRetry) return;
            const pendingMsg = window.__pendingMessageRetry;
            if (!pendingMsg.message?.trim()) {
              delete window.__pendingMessageRetry;
              return;
            }
            const botStatus = botContext?.bot?.isPaused;
            if (botStatus === true) {
              delete window.__pendingMessageRetry;
              return;
            }
            try {
              const payload = {
                botId,
                userId,
                question: pendingMsg.message,
                tempId: pendingMsg.tempId,
                modelName: botContext?.settings?.modelName || \"gpt-3.5-turbo\",
                temperature: botContext?.settings?.temperature || 0.7,
                maxTokens: botContext?.settings?.maxTokens || 150,
                userLocation: userLocation || {
                  country: 'Unknown',
                  city: 'Unknown',
                  language: 'es'
                }
              };
              console.log(`[LOG][RETRY][${new Date().toISOString()}] ðŸ“¤ Payload de reenvÃ­o:`, payload);
              await connection.invoke(\"SendMessage\", convIdNum, payload);
              delete window.__pendingMessageRetry;
            } catch (retryErr) {
              console.error(`[LOG][RETRY][${new Date().toISOString()}] âŒ Error al reenviar mensaje:`, retryErr);
            }
          }, 500);
        }
      } catch (err) {
        console.error('âŒ [initConnection] ERROR CRÃTICO en inicializaciÃ³n:', {
          message: err?.message,
          name: err?.name,
          stack: err?.stack,
          fullError: err
        });
        setConnectionStatus(\"error\");
        setIsConnected(false);
      }
    };
    initConnection();
    return () => {
      if (connectionRef.current) {
        connectionRef.current.off(\"receivemessage\", handleReceiveMessage);
        connectionRef.current.off(\"messagequeued\", handleMessageQueued);
        // âœ… Limpiar listeners correctos
        connectionRef.current.off(\"receivetyping\");
        connectionRef.current.off(\"receivestoptyping\");
        connectionRef.current.off(\"mobilesessionstarted\");
        connectionRef.current.off(\"mobilesessionended\");
        connectionRef.current.stop();
        connectionRef.current = null;
      }
    };
    // Se eliminan dependencias que causaban re-conexiones innecesarias.
    // La lÃ³gica de `handleReceiveMessage` ahora es mÃ¡s robusta con callbacks de estado.
  }, [isOpen, isDemo, userId, botId, propWidgetToken, propWidgetClientSecret]);
  (0,react__WEBPACK_IMPORTED_MODULE_7__.useEffect)(() => {
    if (window.parent && window.parent !== window) {
      let width, height;
      if (isOpen) {
        width = 350; // widgetStyle.width
        height = 600; // widgetStyle.maxHeight
      } else {
        width = 70;
        height = 70;
      }
      window.parent.postMessage({
        type: 'preferred-size',
        width,
        height
      }, '*');
    }
  }, [isOpen]);
  // ðŸ†• EFECTO: Cargar historial cuando se conecta a conversaciÃ³n EXISTENTE en desktop
  // Esto asegura sincronizaciÃ³n cuando cambias entre dispositivos
  (0,react__WEBPACK_IMPORTED_MODULE_7__.useEffect)(() => {
    // Solo en desktop (no mÃ³vil), y solo si hay conversationId establecido
    if (isMobileView || !conversationId || isDemo) return;

    // ðŸ”¹ Si ya cargamos esta conversaciÃ³n, no cargar de nuevo
    if (loadedConversationsRef.current.has(conversationId)) {
      return;
    }

    // â•â•â• HISTORIAL: Cargar desde API (al recargar/conexiÃ³n existente) â•â•â•
    const loadFreshHistory = async () => {
      try {
        const response = await (0,services_conversationsService__WEBPACK_IMPORTED_MODULE_21__.getConversationHistory)(conversationId);
        const historyArray = response?.history || [];
        // Si la conversaciÃ³n estÃ¡ expirada/cerrada en el backend, limpiar cachÃ© y estado
        if (!response || response?.error || response?.status === 410 || response?.status === 404) {
          try {
            clearCache();
            sessionStorage.removeItem(CACHE_KEY);
            localStorage.removeItem(CACHE_KEY);
          } catch (e) {}
          setConversationId(null);
          conversationIdRef.current = null;
          setMessages([]);
          setPromptSent(false);
          promptSentRef.current = false;
          loadedConversationsRef.current.clear();
          return;
        }
        // Si hay historial, procesar normalmente
        const groupedHistory = (0,_utils_chatUtils__WEBPACK_IMPORTED_MODULE_0__.groupConsecutiveFiles)(historyArray);
        const historyMessages = groupedHistory.map(msg => {
          const normalized = (0,_utils_chatUtils__WEBPACK_IMPORTED_MODULE_0__.normalizeMessage)({
            id: msg.id,
            type: msg.type,
            ...(!msg.isGroupedFile && {
              text: msg.text
            }),
            content: msg.text,
            from: msg.fromRole,
            sender: msg.fromRole,
            timestamp: msg.timestamp,
            fromName: msg.fromName,
            fromAvatarUrl: msg.fromAvatarUrl,
            ...(msg.isGroupedFile && {
              isGroupedFile: true,
              files: msg.files
            }),
            ...(!msg.isGroupedFile && (msg.type === 'file' || msg.type === 'image') && {
              fileUrl: msg.fileUrl,
              fileName: msg.fileName,
              fileType: msg.fileType
            })
          });
          return {
            ...normalized,
            status: 'sent',
            color: normalized.color || (0,_utils_colors__WEBPACK_IMPORTED_MODULE_23__.getSenderColor)(normalized.from)
          };
        });
        // HISTORIAL: dedupe por uniqueKey; si vacÃ­o usar id o index para no perder imÃ¡genes distintas
        const uniqueMessages = Array.from(new Map(historyMessages.map((msg, i) => {
          const key = msg.uniqueKey || (msg.id != null ? String(msg.id) : null) || `hist-${i}`;
          return [key, {
            ...msg,
            uniqueKey: msg.uniqueKey || key
          }];
        })).values());
        setMessages(uniqueMessages);
        if (uniqueMessages.some(m => m.from === \"user\")) {
          setPromptSent(true);
          promptSentRef.current = true;
        }
        // Marcar que esta conversaciÃ³n ya fue cargada
        loadedConversationsRef.current.add(conversationId);
      } catch (error) {}
    };

    // ðŸ”¹ PequeÃ±o delay para asegurar que SignalR estÃ¡ conectado
    const timer = setTimeout(() => {
      loadFreshHistory();
    }, 500);
    return () => clearTimeout(timer);
  }, [conversationId, isMobileView, isDemo]);
  (0,react__WEBPACK_IMPORTED_MODULE_7__.useEffect)(() => {
    const timer = setTimeout(() => {
      messagesEndRef.current?.scrollIntoView({
        behavior: \"smooth\"
      });
    }, 50);
    return () => clearTimeout(timer);
  }, [messages]);
  (0,react__WEBPACK_IMPORTED_MODULE_7__.useEffect)(() => {
    if (!isOpen || !conversationId) return;
    let intervalId = null;
    let isUnmounted = false;
    const sendHeartbeat = async () => {
      try {
        const conn = connectionRef.current;
        if (!conn) {
          return;
        }
        if (conn.state === \"Disconnected\") {
          await conn.start();
        }
        if (conn.state === \"Connected\") {
          await conn.invoke(\"UserIsActive\", conversationId);
        }
      } catch (err) {
        setIsBotReady(false); // Asegurarse de que no estÃ© listo si falla
      }
    };
    // Enviar el primer heartbeat inmediatamente (sin logs)
    sendHeartbeat();
    intervalId = setInterval(() => {
      if (!isUnmounted) sendHeartbeat();
    }, 30000);
    return () => {
      isUnmounted = true;
      if (intervalId) clearInterval(intervalId);
    };
  }, [isOpen, conversationId]);
  (0,react__WEBPACK_IMPORTED_MODULE_7__.useEffect)(() => {
    const handlePageClose = () => {
      if (conversationId) {
        // Notificar backend de desconexiÃ³n
        const url = `http://localhost:5006/api/Conversations/${conversationId}/disconnect`;
        if (navigator.sendBeacon) {
          navigator.sendBeacon(url);
        }
      }
    };
    window.addEventListener(\"beforeunload\", handlePageClose);
    return () => {
      window.removeEventListener(\"beforeunload\", handlePageClose);
    };
  }, [conversationId, CACHE_KEY]);
  const [demoMessageCount, setDemoMessageCount] = (0,react__WEBPACK_IMPORTED_MODULE_7__.useState)(0);
  const maxDemoMessages = 5;

  // ðŸ”´ LÃ“GICA DE INACTIVIDAD - CONFIGURACIÃ“N TEMPORAL PARA TESTING
  // Backend cierra a los 15min, widget debe avisar ANTES (usamos 3 min para testing rÃ¡pido)
  const INACTIVITY_TIMEOUT = 3 * 60 * 1000; // 3 minutos
  const INACTIVITY_COUNTDOWN_SEC = 10; // 10 segundos de aviso con conteo regresivo
  const inactivityTimerRef = (0,react__WEBPACK_IMPORTED_MODULE_7__.useRef)(null);
  const closeTimerRef = (0,react__WEBPACK_IMPORTED_MODULE_7__.useRef)(null);
  const inactivityWarningShownRef = (0,react__WEBPACK_IMPORTED_MODULE_7__.useRef)(false);
  const [showInactivityMessage, setShowInactivityMessage] = (0,react__WEBPACK_IMPORTED_MODULE_7__.useState)(false);
  const [inactivityCountdown, setInactivityCountdown] = (0,react__WEBPACK_IMPORTED_MODULE_7__.useState)(null); // 10, 9, 8... 0
  const cleanupInProgressRef = (0,react__WEBPACK_IMPORTED_MODULE_7__.useRef)(false);

  // ðŸ› DEBUG: Log de estado en cada render

  // FunciÃ³n para resetear el timer de inactividad
  const resetInactivityTimer = (0,react__WEBPACK_IMPORTED_MODULE_7__.useCallback)(() => {
    // Pausar inactividad si la sesiÃ³n mÃ³vil estÃ¡ activa o el widget estÃ¡ bloqueado
    if (isMobileSessionActive || isBlockedByOtherDevice) {
      if (inactivityTimerRef.current) clearTimeout(inactivityTimerRef.current);
      if (closeTimerRef.current) clearTimeout(closeTimerRef.current);
      return;
    }
    if (inactivityTimerRef.current) {
      clearTimeout(inactivityTimerRef.current);
    }
    if (closeTimerRef.current) {
      clearTimeout(closeTimerRef.current);
      closeTimerRef.current = null;
    }
    inactivityWarningShownRef.current = false;
    setShowInactivityMessage(false);
    setInactivityCountdown(null);
    if (!isOpen) {
      return; // No contar inactividad si widget estÃ¡ cerrado
    }
    const startTime = new Date();
    inactivityTimerRef.current = setTimeout(() => {
      setShowInactivityMessage(true);
      setInactivityCountdown(INACTIVITY_COUNTDOWN_SEC);
      inactivityWarningShownRef.current = true;

      // DespuÃ©s de 10 segundos (conteo regresivo), cerrar el widget automÃ¡ticamente
      closeTimerRef.current = setTimeout(async () => {
        if (cleanupInProgressRef.current) {
          return;
        }
        cleanupInProgressRef.current = true;
        const currentCacheKey = `chat_widget_${botId}_${userId}`;

        // âœ… PASO 1: Notificar al backend que conversaciÃ³n expirÃ³
        if (conversationIdRef.current && connectionRef.current && connectionRef.current.state === \"Connected\") {
          try {
            await connectionRef.current.invoke(\"NotifyWidgetExpired\", conversationIdRef.current);
          } catch (err) {
            // Eliminado log de inactividad
          }
        } else {
          // ...existing code...
        }

        // âœ… PASO 2: LIMPIAR CACHÃ‰ - Solo cuando cierre por inactividad
        try {
          clearCache();
          sessionStorage.removeItem(currentCacheKey);
          localStorage.removeItem(currentCacheKey);

          // Limpieza total de refs y estados
          setConversationId(null);
          conversationIdRef.current = null;
          setMessages([]);
          setPromptSent(false);
          promptSentRef.current = false;
          welcomeShownRef.current = false;
          loadedConversationsRef.current = new Set();
        } catch (e) {
          // Eliminado log de inactividad
        }
        setIsOpen(false);
        setShowInactivityMessage(false);
        setInactivityCountdown(null);
        inactivityWarningShownRef.current = false;
        setTimeout(() => {
          cleanupInProgressRef.current = false;
        }, 1000);
      }, INACTIVITY_COUNTDOWN_SEC * 1000); // 10 segundos de aviso
    }, INACTIVITY_TIMEOUT);
  }, [isOpen, isMobileSessionActive, isBlockedByOtherDevice, botId, userId]);

  // FunciÃ³n para manejar actividad del usuario (usada por listeners y componentes hijos)
  const handleUserActivity = (0,react__WEBPACK_IMPORTED_MODULE_7__.useCallback)(e => {
    // Si se llama sin evento (desde MessageInput), simplemente resetear
    if (!e) {
      resetInactivityTimer();
      return;
    }

    // Si se llama con evento (desde event listeners), verificar que sea dentro del widget
    // âœ… Verificar que actualRootRef.current existe antes de acceder a contains
    if (actualRootRef.current && actualRootRef.current.contains(e.target)) {
      const eventInfo = `tipo=${e.type}, target=${e.target.tagName}${e.target.id ? '#' + e.target.id : ''}`;
      resetInactivityTimer();
    } else {
      // ...existing code...
    }
  }, [resetInactivityTimer]);

  // Detectar interacciÃ³n del usuario para resetear timer
  (0,react__WEBPACK_IMPORTED_MODULE_7__.useEffect)(() => {
    if (!isOpen) {
      return;
    }

    // Escuchar mÃºltiples eventos de interacciÃ³n en el documento
    const events = ['mousedown', 'keydown', 'touchstart', 'click', 'input'];
    events.forEach(event => {
      document.addEventListener(event, handleUserActivity, true); // true = captura en fase de captura
    });

    // Iniciar el timer cuando el widget se abre
    resetInactivityTimer();
    return () => {
      events.forEach(event => {
        document.removeEventListener(event, handleUserActivity, true);
      });
      if (inactivityTimerRef.current) {
        clearTimeout(inactivityTimerRef.current);
      }
      if (closeTimerRef.current) {
        clearTimeout(closeTimerRef.current);
      }
    };
  }, [isOpen, resetInactivityTimer, handleUserActivity]);

  // ðŸ†• EFFECT: Cuando mÃ³vil se cierra, reanudar timer de inactividad
  (0,react__WEBPACK_IMPORTED_MODULE_7__.useEffect)(() => {
    if (isMobileSessionActive) {
      // Pausar - limpiar cualquier timer activo
      if (inactivityTimerRef.current) clearTimeout(inactivityTimerRef.current);
      if (closeTimerRef.current) clearTimeout(closeTimerRef.current);
    } else if (isOpen) {
      // Reanudar - reiniciar el timer
      resetInactivityTimer();
    }
  }, [isMobileSessionActive, isOpen, resetInactivityTimer]);

  // ðŸ”´ Conteo regresivo: 10, 9, 8... cuando se muestra alerta de inactividad
  (0,react__WEBPACK_IMPORTED_MODULE_7__.useEffect)(() => {
    if (!showInactivityMessage) return;
    const id = setInterval(() => {
      setInactivityCountdown(prev => {
        if (prev === null || prev <= 1) return 0;
        return prev - 1;
      });
    }, 1000);
    return () => clearInterval(id);
  }, [showInactivityMessage]);

  // ðŸ”´ LÃ“GICA DE INACTIVIDAD CON WIDGET CERRADO
  // Si el widget estÃ¡ cerrado por mÃ¡s de 3 minutos, limpiar cachÃ© y cerrar conversaciÃ³n
  const inactivityClosedTimerRef = (0,react__WEBPACK_IMPORTED_MODULE_7__.useRef)(null);
  (0,react__WEBPACK_IMPORTED_MODULE_7__.useEffect)(() => {
    // Si widget estÃ¡ abierto o cerrado, no limpiar cachÃ© por inactividad aquÃ­
    if (inactivityClosedTimerRef.current) {
      clearTimeout(inactivityClosedTimerRef.current);
      inactivityClosedTimerRef.current = null;
    }
    // El cachÃ© solo se limpia por cierre explÃ­cito o expiraciÃ³n real (evento de inactividad en el widget abierto)
    return;
  }, [isOpen, CACHE_KEY]);

  // Resetear timer cuando se envÃ­a un mensaje
  const handleResetInactivityOnMessage = (0,react__WEBPACK_IMPORTED_MODULE_7__.useCallback)(() => {
    resetInactivityTimer();
  }, [resetInactivityTimer]);

  // Helper: clave normalizada para comparar URLs de archivo
  const fileUrlForKey = (0,react__WEBPACK_IMPORTED_MODULE_7__.useCallback)(url => {
    if (!url || typeof url !== \"string\") return \"\";
    try {
      return url.startsWith(\"http\") ? new URL(url).pathname : (url.split(\"?\")[0] || \"\").trim();
    } catch (e) {
      return (url || \"\").trim();
    }
  }, []);

  // TIEMPO REAL: Mensaje optimista al enviar archivo. Solo aÃ±adir si ReceiveMessage no lo enviÃ³ ya (llega antes que SendFile retorne).
  const handleFileSent = (0,react__WEBPACK_IMPORTED_MODULE_7__.useCallback)(data => {
    if (!data) return;
    pendingFileMessageRef.current = null;
    const newFileUrl = data.fileUrl || data.multipleFiles?.[0]?.fileUrl || data.multipleFiles?.[0]?.filePath;
    const newKey = fileUrlForKey(newFileUrl);
    setMessages(prev => {
      // Si el servidor ya enviÃ³ ReceiveMessage con este fileUrl, no aÃ±adir optimista (evita duplicado)
      if (newKey) {
        const alreadyFromServer = prev.some(m => {
          if (m.from !== \"user\" || !m.multipleFiles?.length) return false;
          const url = m.multipleFiles[0]?.fileUrl ?? m.multipleFiles[0]?.filePath ?? m.multipleFiles[0]?.url;
          return fileUrlForKey(url) === newKey;
        });
        if (alreadyFromServer) return prev;
      }
      const tempId = (0,uuid__WEBPACK_IMPORTED_MODULE_8__[\"default\"])();
      const fileMsg = (0,_utils_chatUtils__WEBPACK_IMPORTED_MODULE_0__.normalizeMessage)({
        tempId,
        id: tempId,
        from: \"user\",
        status: \"sent\",
        timestamp: new Date().toISOString(),
        multipleFiles: data.multipleFiles || (data.fileUrl ? [{
          fileUrl: data.fileUrl,
          fileName: data.fileName,
          fileType: data.fileType,
          fileContent: data.fileContent
        }] : [])
      });
      pendingFileMessageRef.current = fileMsg;
      return [...prev, fileMsg];
    });
    setFileInputKey(k => k + 1); // ðŸ”„ Forzar input file fresco para que la siguiente selecciÃ³n dispare onChange
    handleResetInactivityOnMessage();
    handleUserActivity?.();
  }, [fileUrlForKey, handleResetInactivityOnMessage, handleUserActivity]);

  // LOGS de creaciÃ³n de conversaciÃ³n y mensajes
  // Variable para guardar el mensaje pendiente
  let pendingUserMessage = null;
  const sendMessage = async () => {
    if (!isBotReady) return;
    const trimmedMessage = message.trim();
    if (!trimmedMessage) return;
    if (isMobileLocked) return;

    // LOG: Mensaje de usuario con origen y userId
    if (isMobileView) {
      console.log('[LOG][ORIGEN] ðŸ“± Mensaje enviado DESDE MÃ“VIL:', trimmedMessage);
    } else {
      console.log('[LOG][ORIGEN] ðŸ’» Mensaje enviado DESDE WIDGET:', trimmedMessage);
    }
    console.log('[LOG][MESSAGE] Usuario envÃ­a mensaje:', trimmedMessage);
    console.log('[LOG][USERID] userId recibido en ChatWidget:', userId, typeof userId);

    // Optimistic UI: mostrar el mensaje del usuario inmediatamente
    const tempId = (0,uuid__WEBPACK_IMPORTED_MODULE_8__[\"default\"])();
    const userMessageForDisplay = (0,_utils_chatUtils__WEBPACK_IMPORTED_MODULE_0__.normalizeMessage)({
      tempId,
      from: \"user\",
      text: trimmedMessage,
      status: \"sending\",
      timestamp: new Date().toISOString()
    });
    setMessages(prev => [...prev, userMessageForDisplay]);
    setMessage(\"\");
    handleResetInactivityOnMessage();
    handleUserActivity(); // Extiende el periodo de limpieza por inactividad

    // Enviar al backend si la conexiÃ³n estÃ¡ lista
    let connection = connectionRef.current;
    let convId = conversationIdRef.current;
    let retries = 0;

    // ðŸ”„ Esperar hasta que la conexiÃ³n estÃ© realmente lista
    while (retries < 20) {
      // 20 retries * 200ms = 4 segundos mÃ¡ximo
      connection = connectionRef.current;
      convId = conversationIdRef.current;
      if (connection && connection.state === \"Connected\" && convId) {
        break;
      }
      if (retries > 0 && retries % 5 === 0) {
        console.log(`[LOG][MESSAGE] â³ Esperando conexiÃ³n... intento ${retries}/20, estado: ${connection?.state || 'null'}`);
      }
      await new Promise(res => setTimeout(res, 200));
      retries++;
    }

    // Verificar estado final de la conexiÃ³n
    if (!connection || connection.state !== \"Connected\" || !convId) {
      console.error('[LOG][MESSAGE] âŒ No se pudo enviar - conexiÃ³n no lista:', {
        hasConnection: !!connection,
        connectionState: connection?.state,
        convId,
        retries
      });
      setMessages(prev => prev.map(m => m.tempId === tempId ? {
        ...m,
        status: \"error\"
      } : m));
      return;
    }
    try {
      // ðŸ”´ CRÃTICO: El backend espera userId como int? (nullable int)
      // Si userId es \"anon\" o no es un nÃºmero vÃ¡lido, enviar null
      let numericUserId = null;
      if (userId !== null && userId !== undefined && userId !== 'anon') {
        const parsed = parseInt(userId, 10);
        if (!isNaN(parsed) && parsed > 0) {
          numericUserId = parsed;
        }
      }
      const payload = {
        botId,
        userId: numericUserId,
        // null si es anon, o nÃºmero si es vÃ¡lido
        question: trimmedMessage,
        tempId,
        modelName: botContext?.settings?.modelName || \"gpt-3.5-turbo\",
        temperature: botContext?.settings?.temperature || 0.7,
        maxTokens: botContext?.settings?.maxTokens || 150,
        userLocation: userLocation || {
          country: 'Unknown',
          city: 'Unknown',
          language: 'es'
        },
        origen: isMobileView ? 'movil' : 'widget'
      };
      // LOG: Payload enviado al backend con origen y userId
      console.log('[LOG][MESSAGE] ðŸ“¤ Payload enviado al backend:', payload);
      console.log('[LOG][MESSAGE] ðŸ”Œ Estado conexiÃ³n antes de invoke:', connection.state);
      console.log('[LOG][MESSAGE] ðŸ†” userId original:', userId, 'â†’ numericUserId:', numericUserId);
      await connection.invoke(\"SendMessage\", convId, payload);
      console.log('[LOG][MESSAGE] âœ… invoke(\"SendMessage\") completado para:', trimmedMessage);
    } catch (err) {
      console.error('[LOG][MESSAGE] âŒ Error al enviar mensaje:', {
        error: err?.message || err,
        connectionState: connection?.state,
        convId,
        isMobileView
      });

      // Si el error es por token expirado, guardar el mensaje pendiente y renovar el token
      if (err?.response?.status === 401) {
        pendingUserMessage = {
          ...payload
        };
        // Renovar el token y reintentar
        const newToken = await renewWidgetToken(botId);
        if (newToken) {
          localStorage.setItem('token', newToken);
          // Reintentar el envÃ­o del mensaje pendiente
          try {
            // Esperar a que la conexiÃ³n estÃ© lista
            let retries = 0;
            while ((!isConnected || !conversationIdRef.current || !connectionRef.current || connectionRef.current.state !== \"Connected\") && retries < 10) {
              await new Promise(res => setTimeout(res, 200));
              retries++;
            }
            if (isConnected && conversationIdRef.current && connectionRef.current && connectionRef.current.state === \"Connected\") {
              await connectionRef.current.invoke(\"SendMessage\", conversationIdRef.current, pendingUserMessage);
              console.log('[LOG][MESSAGE][RETRY] âœ… Mensaje pendiente reenviado tras renovar token:', pendingUserMessage);
              pendingUserMessage = null;
            } else {
              console.error('[LOG][MESSAGE][RETRY] âŒ No se pudo reenviar el mensaje pendiente tras renovar token.');
            }
          } catch (retryErr) {
            console.error('[LOG][MESSAGE][RETRY] âŒ Error al reenviar mensaje pendiente tras renovar token:', retryErr);
          }
        }
      }
      setMessages(prev => prev.map(m => m.tempId === tempId ? {
        ...m,
        status: \"error\"
      } : m));
      setIsTyping(false);
      setTypingSender(null);
    }
  };

  // FunciÃ³n para renovar el token del widget (debe implementarse segÃºn tu backend)
  async function renewWidgetToken(botId) {
    try {
      // AquÃ­ deberÃ­as hacer una peticiÃ³n al backend para obtener un nuevo token pÃºblico
      // Ejemplo usando fetch:
      const response = await fetch(`/api/Bots/${botId}/public-token`, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json'
        }
      });
      if (response.ok) {
        const data = await response.json();
        return data.token;
      }
      return null;
    } catch (e) {
      return null;
    }
  }
  const isColorDark = hexColor => {
    if (!hexColor) return false;
    const color = hexColor.replace(\"#\", \"\");
    const r = parseInt(color.substring(0, 2), 16);
    const g = parseInt(color.substring(2, 4), 16);
    const b = parseInt(color.substring(4, 6), 16);
    const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
    return luminance < 0.5;
  };

  // Mejor contraste para el tÃ­tulo del widget
  function getContrastTextColor(bgColor) {
    if (!bgColor) return \"#000000\";
    let color = bgColor.replace(\"#\", \"\");
    if (color.length === 3) {
      color = color[0] + color[0] + color[1] + color[1] + color[2] + color[2];
    }
    const r = parseInt(color.substring(0, 2), 16);
    const g = parseInt(color.substring(2, 4), 16);
    const b = parseInt(color.substring(4, 6), 16);
    // YIQ formula for contrast
    const yiq = (r * 299 + g * 587 + b * 114) / 1000;
    return yiq >= 180 ? \"#000000\" : \"#ffffff\";
  }
  const headerTextColor = getContrastTextColor(headerBackground);

  // âœ… Estilos
  const widgetWidth = Math.min(Math.max(280, styleWidth || 380), 600);
  const widgetHeight = Math.min(Math.max(400, styleHeight || 600), 800);
  const widgetStyle = {
    backgroundColor,
    color: textColor,
    fontFamily,
    borderRadius: isMobileView ? \"0px\" : \"16px\",
    width: isMobileView ? \"100%\" : `${widgetWidth}px`,
    maxWidth: isMobileView ? \"100%\" : `${widgetWidth}px`,
    height: \"100%\",
    maxHeight: isMobileView ? \"100%\" : `${widgetHeight}px`,
    boxShadow: isMobileView ? \"none\" : \"0 2px 15px rgba(0,0,0,0.15)\",
    display: \"flex\",
    flexDirection: \"column\",
    justifyContent: \"space-between\",
    overflow: \"hidden\",
    boxSizing: \"border-box\"
  };
  const positionStyles = {
    \"bottom-right\": {
      bottom: \"20px\",
      right: \"20px\"
    },
    \"bottom-left\": {
      bottom: \"20px\",
      left: \"20px\"
    },
    \"top-right\": {
      top: \"20px\",
      right: \"20px\"
    },
    \"top-left\": {
      top: \"20px\",
      left: \"20px\"
    },
    \"center-left\": {
      top: \"50%\",
      left: \"20px\",
      transform: \"translateY(-50%)\"
    },
    \"center-right\": {
      top: \"50%\",
      right: \"20px\",
      transform: \"translateY(-50%)\"
    }
  };

  // Position styles for the small launcher button when the widget is closed.
  const launcherPositionStyles = {
    \"bottom-right\": {
      position: 'absolute',
      bottom: '0px',
      right: '0px'
    },
    \"bottom-left\": {
      position: 'absolute',
      bottom: '0px',
      left: '0px'
    },
    \"top-right\": {
      position: 'absolute',
      top: '0px',
      right: '0px'
    },
    \"top-left\": {
      position: 'absolute',
      top: '0px',
      left: '0px'
    },
    \"center-left\": {
      position: 'absolute',
      top: '50%',
      left: '0px',
      transform: 'translateY(-50%)'
    },
    \"center-right\": {
      position: 'absolute',
      top: '50%',
      right: '0px',
      transform: 'translateY(-50%)'
    }
  };

  // The wrapper inside the iframe should not be fixed or use viewport units.
  // Positioning of the iframe itself should be decided by the host page (parent).

  const wrapperStyle = {
    position: \"relative\",
    zIndex: 9999,
    // Let clicks pass through wrapper unless inner elements set pointerEvents:auto
    pointerEvents: \"none\",
    width: containerSize && containerSize.width ? `${containerSize.width}px` : '100%',
    height: containerSize && containerSize.height ? `${containerSize.height}px` : '100%'
  };

  // If we're rendering inside the dashboard preview, position the widget fixed
  // so it doesn't get caught by the page layout (nav) and so top positions sit under the nav.
  const previewFixedStyle = previewMode ? function () {
    // ðŸ“± MÃ“VIL: Ocupar todo el ancho y alto de la pantalla
    if (isMobileView) {
      return {
        position: 'fixed',
        zIndex: 99999,
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        width: '100%',
        height: '100vh',
        margin: 0,
        padding: 0
      };
    }

    // ðŸ–¥ï¸ WIDGET/DEMO: Usar posicionamiento normal
    const topOffset = 80; // px to avoid overlapping the dashboard nav/header
    const w = `${widgetWidth}px`;
    switch (position) {
      case 'bottom-right':
        return {
          position: 'fixed',
          zIndex: 99999,
          right: '20px',
          bottom: '20px',
          width: w
        };
      case 'bottom-left':
        return {
          position: 'fixed',
          zIndex: 99999,
          left: '20px',
          bottom: '20px',
          width: w
        };
      case 'top-right':
        return {
          position: 'fixed',
          zIndex: 99999,
          right: '20px',
          top: `${topOffset}px`,
          width: w
        };
      case 'top-left':
        return {
          position: 'fixed',
          zIndex: 99999,
          left: '20px',
          top: `${topOffset}px`,
          width: w
        };
      case 'center-left':
        return {
          position: 'fixed',
          zIndex: 99999,
          left: '20px',
          top: '50%',
          transform: 'translateY(-50%)',
          width: w
        };
      case 'center-right':
      default:
        return {
          position: 'fixed',
          zIndex: 99999,
          right: '20px',
          top: '50%',
          transform: 'translateY(-50%)',
          width: w
        };
    }
  }() : {};

  // Outer style to use when rendering in preview mode (dashboard):
  // apply fixed positioning and a sensible width so the widget doesn't get compressed
  const outerStyle = previewMode ? {
    // previewFixedStyle already computes fixed position + width
    ...previewFixedStyle,
    // ensure the container receives pointer events in preview so the widget is interactive
    pointerEvents: 'auto',
    // let the inner widget size itself; avoid forcing 100% height which can compress it
    height: 'auto',
    // keep a small margin so it doesn't stick to edges
    margin: 0
  } : wrapperStyle;
  const openImageModal = (images, clickedImageUrl, blobUrlsMap = {}, startIndex = 0) => {
    // Reset state then open modal after a tiny delay so layout stabilizes
    setImageGroup([]);
    setImageGroupBlobUrls({});
    setActiveImageIndex(0);
    setIsImageModalOpen(false);
    setTimeout(() => {
      // ðŸ”¹ Si pasaron startIndex directamente, usarlo. Si no, intentar encontrar por URL
      let index = startIndex;
      if (startIndex === 0 && clickedImageUrl) {
        // Intentar encontrar por URL si startIndex es 0 (podrÃ­a ser coincidencia)
        const foundIndex = images.findIndex(img => {
          try {
            const url = img.fileUrl && String(img.fileUrl).startsWith(\"http\") ? img.fileUrl : `http://localhost:5006${img.fileUrl}`;
            return url === clickedImageUrl;
          } catch (e) {
            return false;
          }
        });
        if (foundIndex >= 0) index = foundIndex;
      }
      setImageGroup(images || []);
      setImageGroupBlobUrls(blobUrlsMap || {});
      setActiveImageIndex(index >= 0 ? index : 0);
      setIsImageModalOpen(true);
    }, 10); // small delay to ensure the modal opens after DOM updates
  };
  (0,react__WEBPACK_IMPORTED_MODULE_7__.useEffect)(() => {
    if (!isDemo || !isOpen) return;
    const getTypingDuration = text => {
      const base = 500; // mÃ­nimo 0.5s
      const perChar = 40; // 40ms por caracter
      const max = 2500; // tope 2.5s
      return Math.min(max, base + text.length * perChar);
    };
    const demoSequence = [{
      sender: \"bot\",
      content: \"Â¡Hola! Soy tu asistente virtual. Â¿CÃ³mo puedo ayudarte hoy?\",
      typing: 1200,
      after: 800
    }, {
      sender: \"user\",
      content: \"Hola, quiero informaciÃ³n sobre sus servicios.\",
      after: 1500
    }, {
      sender: \"bot\",
      content: \"Claro, ofrecemos consultorÃ­a y desarrollo de software a medida.\",
      typing: 1500,
      after: 1000
    }, {
      sender: \"user\",
      content: \"Â¿Y cuÃ¡l es su horario de atenciÃ³n?\",
      after: 1800
    }, {
      sender: \"bot\",
      content: \"Nuestro horario es de lunes a viernes de 8:00 a.m. a 5:00 p.m.\",
      typing: 1800,
      after: 800
    }];
    let totalDelay = 0;
    const timeoutIds = [];
    let counter = 0;
    demoSequence.forEach(item => {
      if (item.sender === \"bot\") {
        const typingDuration = item.typing ?? getTypingDuration(item.content);
        const typingOnId = setTimeout(() => {
          setTypingSender(item.sender);
          setIsTyping(true);
        }, totalDelay);
        timeoutIds.push(typingOnId);
        totalDelay += typingDuration;
        const messageId = setTimeout(() => {
          const newMsg = (0,_utils_chatUtils__WEBPACK_IMPORTED_MODULE_0__.normalizeMessage)({
            id: `demo-${counter++}-${Date.now()}`,
            from: item.sender === 'bot' ? 'bot' : 'user',
            text: item.content,
            type: \"text\",
            timestamp: new Date().toISOString(),
            imageGroup: [],
            files: []
          });
          setMessages(prev => [...prev, newMsg]);
          setIsTyping(false);
          setTypingSender(null);
        }, totalDelay);
        // timeoutIds.push(messageId); // Eliminar duplicado fuera de contexto

        totalDelay += item.after ?? 0;
      } else {
        totalDelay += item.after ?? 0;
        const messageId = setTimeout(() => {
          const newMsg = (0,_utils_chatUtils__WEBPACK_IMPORTED_MODULE_0__.normalizeMessage)({
            id: `demo-${counter++}-${Date.now()}`,
            from: 'user',
            text: item.content,
            type: \"text\",
            timestamp: new Date().toISOString(),
            imageGroup: [],
            files: []
          });
          setMessages(prev => [...prev, newMsg]);
        }, totalDelay);
        timeoutIds.push(messageId);
      }
    });
    return () => {
      timeoutIds.forEach(id => clearTimeout(id));
      setIsTyping(false);
      setTypingSender(null);
    };
  }, [isDemo, isOpen]);
  const isInputDisabled = isDemo ? true : !isConnected || isMobileLocked || isBlockedByOtherDevice || isMobileConversationExpired;

  // ðŸ“ Auto-focus del input al abrir el chat (widget o mÃ³vil): cursor parpadeando y en mÃ³vil se muestra el teclado
  (0,react__WEBPACK_IMPORTED_MODULE_7__.useEffect)(() => {
    if (!isOpen && !isMobileView) return;
    const t = setTimeout(() => {
      if (textareaRef.current && !isInputDisabled) {
        textareaRef.current.focus({
          preventScroll: false
        });
      }
    }, isMobileView ? 400 : 300);
    return () => clearTimeout(t);
  }, [isOpen, isMobileView, isInputDisabled]);

  // Mensaje especÃ­fico del placeholder cuando el input estÃ¡ deshabilitado (textos cortos para una lÃ­nea)
  const inputDisabledPlaceholder = (() => {
    if (!isInputDisabled) return null;
    if (isDemo) return \"Modo demo: no puedes escribir.\";
    if (isMobileConversationExpired) return \"ConversaciÃ³n expirada.\";
    if (isBlockedByOtherDevice) return \"Abierto en otro dispositivo.\";
    if (isMobileLocked) return \"SesiÃ³n mÃ³vil activa.\";
    if (!isConnected) return \"Conectando...\";
    return \"Chat no disponible.\";
  })();

  // ðŸ” DEBUG: Log del estado del input
  (0,react__WEBPACK_IMPORTED_MODULE_7__.useEffect)(() => {}, [isInputDisabled, isDemo, isConnected, isMobileLocked, isBlockedByOtherDevice, isMobileConversationExpired, isMobileView]);

  // --- FIN DE HOOKS ---

  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_7___default().createElement(\"div\", {
    ref: actualRootRef,
    style: outerStyle
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_7___default().createElement(\"style\", null, `
        @keyframes spin { 
          from { transform: rotate(0deg);} 
          to { transform: rotate(360deg);} 
        }
      `), !isOpen && !isMobileView ?
  /*#__PURE__*/
  // ðŸ”˜ BotÃ³n flotante cuando estÃ¡ cerrado (oculto en vista mÃ³vil)
  react__WEBPACK_IMPORTED_MODULE_7___default().createElement(\"button\", {
    onClick: () => setIsOpen(true),
    \"aria-label\": \"Abrir chat\",
    style: {
      backgroundColor: headerBackground,
      borderRadius: \"50%\",
      width: \"70px\",
      height: \"70px\",
      border: \"none\",
      cursor: \"pointer\",
      display: \"flex\",
      alignItems: \"center\",
      justifyContent: \"center\",
      boxShadow: \"0 2px 10px rgba(0,0,0,0.2)\",
      overflow: \"hidden\",
      padding: 0,
      pointerEvents: \"auto\",
      // Asegurar que el botÃ³n reciba clicks
      // Position according to configured position inside the iframe container
      ...(launcherPositionStyles[position] || launcherPositionStyles['bottom-right'])
    }
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_7___default().createElement(\"div\", {
    style: {
      width: \"72px\",
      height: \"72px\",
      borderRadius: \"50%\",
      display: \"flex\",
      alignItems: \"center\",
      justifyContent: \"center\",
      overflow: \"hidden\"
    }
  }, (0,_utils_chatUtils__WEBPACK_IMPORTED_MODULE_0__.isEmoji)(avatarUrl) ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_7___default().createElement(\"span\", {
    style: {
      fontSize: \"32px\",
      lineHeight: 1,
      userSelect: \"none\",
      fontFamily: \"'Segoe UI Emoji', 'Apple Color Emoji', 'Noto Color Emoji', 'Android Emoji', 'EmojiOne Color', 'Twemoji Mozilla', sans-serif\"
    }
  }, avatarUrl) : /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_7___default().createElement(\"img\", {
    src: avatarUrl?.trim() ? avatarUrl : defaultAvatar,
    alt: \"Avatar\",
    style: {
      width: \"60px\",
      height: \"60px\",
      borderRadius: \"50%\",
      objectFit: \"cover\"
    },
    onError: e => {
      e.target.style.display = \"none\";
    }
  }))) :
  /*#__PURE__*/
  // ðŸ’¬ Widget abierto
  react__WEBPACK_IMPORTED_MODULE_7___default().createElement(\"div\", {
    style: {
      ...widgetStyle,
      pointerEvents: \"auto\",
      margin: '0 auto',
      // ðŸ“± MÃ“VIL: Ocupar todo el espacio disponible
      ...(isMobileView ? {
        width: '100%',
        height: '100vh',
        maxWidth: '100%',
        maxHeight: '100vh',
        borderRadius: 0,
        margin: 0,
        padding: 0
      } : {
        // ðŸ–¥ï¸ WIDGET/DEMO: Usar tamaÃ±os normales
        height: previewMode ? widgetStyle.maxHeight : widgetStyle.height
      }),
      position: 'relative'
    }
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_7___default().createElement(_chat_MobileConversationExpired__WEBPACK_IMPORTED_MODULE_18__[\"default\"], {
    isExpired: isMobileConversationExpired
  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_7___default().createElement(\"div\", {
    style: {
      backgroundColor: headerBackground,
      width: \"100%\",
      minHeight: isMobileView ? \"84px\" : \"76px\",
      height: isMobileView ? \"84px\" : \"76px\",
      boxSizing: \"border-box\",
      // ðŸ“± MÃ“VIL: Sin border-radius para ocupar esquinas completas
      borderTopLeftRadius: isMobileView ? 0 : \"16px\",
      borderTopRightRadius: isMobileView ? 0 : \"16px\",
      display: \"flex\",
      alignItems: \"center\",
      justifyContent: \"space-between\",
      boxShadow: \"0 2px 4px rgba(0,0,0,0.08)\",
      // ðŸ“± MÃ“VIL: Padding simÃ©trico (44px avatar + 20 arriba + 20 abajo = 84px)
      paddingTop: isMobileView ? \"20px\" : 0,
      paddingBottom: isMobileView ? \"20px\" : 0,
      paddingLeft: isMobileView ? \"16px\" : 0,
      paddingRight: isMobileView ? \"16px\" : \"8px\"
    }
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_7___default().createElement(\"div\", {
    style: {
      display: \"flex\",
      alignItems: \"center\",
      gap: isMobileView ? \"14px\" : \"12px\",
      paddingLeft: isMobileView ? \"8px\" : \"16px\",
      alignSelf: \"center\" // Asegurar centrado vertical en el header
    }
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_7___default().createElement(\"div\", {
    style: {
      width: isMobileView ? \"44px\" : \"50px\",
      height: isMobileView ? \"44px\" : \"50px\",
      borderRadius: \"50%\",
      display: \"flex\",
      alignItems: \"center\",
      justifyContent: \"center\",
      overflow: \"hidden\",
      backgroundColor: \"rgba(255,255,255,0.15)\",
      flexShrink: 0,
      boxSizing: \"border-box\",
      // MÃ³vil: bajar el cÃ­rculo (margin-top empuja el bloque hacia abajo)
      ...(isMobileView && {
        marginTop: \"4px\"
      })
    }
  }, (0,_utils_chatUtils__WEBPACK_IMPORTED_MODULE_0__.isEmoji)(avatarUrl) ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_7___default().createElement(\"span\", {
    style: {
      display: \"flex\",
      alignItems: \"center\",
      justifyContent: \"center\",
      width: \"100%\",
      height: \"100%\",
      fontSize: isMobileView ? \"24px\" : \"26px\",
      lineHeight: 0,
      userSelect: \"none\",
      fontFamily: \"'Segoe UI Emoji', 'Apple Color Emoji', 'Noto Color Emoji', 'Android Emoji', 'EmojiOne Color', 'Twemoji Mozilla', sans-serif\"
    }
  }, avatarUrl) : /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_7___default().createElement(\"img\", {
    src: avatarUrl?.trim() ? avatarUrl : defaultAvatar,
    alt: \"Avatar\",
    style: {
      width: isMobileView ? \"40px\" : \"46px\",
      height: isMobileView ? \"40px\" : \"46px\",
      borderRadius: \"50%\",
      objectFit: \"cover\",
      display: \"block\",
      margin: 0,
      padding: 0
    },
    onError: e => {
      e.target.style.display = \"none\";
    }
  })), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_7___default().createElement(\"span\", {
    style: {
      fontSize: \"16px\",
      color: headerTextColor,
      fontFamily: fontFamily || \"Arial\",
      fontWeight: \"600\",
      textShadow: \"1px 1px 2px rgba(0,0,0,0.2)\"
    }
  }, title)), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_7___default().createElement(\"div\", {
    style: {
      display: 'flex',
      alignItems: 'center',
      gap: '12px',
      paddingRight: '12px'
    }
  }, !isMobileView && (conversationId || conversationIdRef.current) && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_7___default().createElement(\"div\", {
    style: {
      display: 'flex',
      alignItems: 'center',
      gap: 4,
      background: 'transparent',
      flexShrink: 0,
      overflow: 'hidden'
    }
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_7___default().createElement(\"div\", {
    style: {
      textAlign: 'right',
      color: headerTextColor,
      fontSize: 10,
      lineHeight: 1.1,
      marginRight: 0,
      minWidth: 55,
      display: 'flex',
      flexDirection: 'column',
      justifyContent: 'flex-start',
      alignItems: 'flex-end',
      height: '50px',
      marginTop: '10px',
      marginBottom: '0px',
      paddingTop: '0px'
    }
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_7___default().createElement(\"div\", {
    style: {
      fontWeight: 600,
      fontSize: 9.5,
      color: headerTextColor,
      marginBottom: 0
    }
  }, \"Contin\\xFAa en\", /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_7___default().createElement(\"br\", null), \"tu m\\xF3vil\")), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_7___default().createElement(\"div\", {
    style: {
      display: 'flex',
      flexDirection: 'column',
      alignItems: 'center',
      justifyContent: 'center',
      marginLeft: '0px',
      flexShrink: 0
    }
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_7___default().createElement(\"div\", {
    style: {
      background: '#ffffff',
      padding: 4,
      borderRadius: 8,
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      boxShadow: '0 4px 12px rgba(0,0,0,0.06)'
    }
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_7___default().createElement(qrcode_react__WEBPACK_IMPORTED_MODULE_24__.QRCodeCanvas, {
    value: (() => {
      const base = \"http://localhost:3000\" || (0);
      const conv = conversationId || conversationIdRef.current || '';
      if (!conv) return base;
      // URL corta: solo bot, conversation, userId (sin token ni fingerprint para QR mÃ¡s escaneable)
      // El mÃ³vil obtiene token del backend y genera fingerprint localmente
      const params = new URLSearchParams();
      params.set('bot', String(botId));
      params.set('conversation', String(conv));
      if (userId != null && userId !== '') params.set('userId', String(userId));
      return `${base}/chat/mobile?${params.toString()}`;
    })(),
    size: 48,
    level: \"L\"
  })))), !isMobileView && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_7___default().createElement(\"button\", {
    onClick: () => {
      // âœ… Al cerrar manualmente, el useEffect de cierre manual (lÃ­neas 902-1008) 
      // detectarÃ¡ la transiciÃ³n isOpen=trueâ†’false y activarÃ¡ el timer de 3 minutos
      // NO es necesario hacer nada mÃ¡s aqu                   
      // Solo cerrar el widget - el useEffect maneja el resto
      setIsOpen(false);
    },
    \"aria-label\": \"Cerrar chat\",
    style: {
      background: \"transparent\",
      border: \"none\",
      color: headerTextColor,
      fontSize: \"18px\",
      cursor: \"pointer\"
    }
  }, \"\\u2715\"))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_7___default().createElement(react_transition_group__WEBPACK_IMPORTED_MODULE_5__[\"default\"], null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_7___default().createElement(react_transition_group__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {
    key: showConnectionDebug ? connectionStatus : \"hidden\",
    timeout: 300,
    nodeRef: nodeRef,
    unmountOnExit: true,
    mountOnEnter: true,
    onEnter: () => {
      const node = nodeRef.current;
      if (!node) return;
      node.style.opacity = 0;
      node.style.transform = \"translateY(-5px)\";
      requestAnimationFrame(() => {
        node.style.transition = \"all 0.3s ease\";
        node.style.opacity = 1;
        node.style.transform = \"translateY(0)\";
      });
    },
    onExit: () => {
      const node = nodeRef.current;
      if (!node) return;
      node.style.opacity = 1;
      node.style.transform = \"translateY(0)\";
      requestAnimationFrame(() => {
        node.style.transition = \"all 0.3s ease\";
        node.style.opacity = 0;
        node.style.transform = \"translateY(-5px)\";
      });
    }
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_7___default().createElement(\"div\", {
    ref: nodeRef
  }, showConnectionDebug && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_7___default().createElement(\"div\", {
    style: {
      fontSize: \"12px\",
      color: \"#000\",
      backgroundColor: connectionStatus === \"conectado\" ? pastelColors.conectadoVerde : connectionStatus.includes(\"reconectando\") ? pastelColors.reconectando : connectionStatus.includes(\"error\") ? pastelColors.error : pastelColors.desconectado,
      padding: \"4px 8px\",
      textAlign: \"center\",
      marginBottom: \"4px\"
    }
  }, \"Estado de conexi\\xF3n: \", connectionStatus)))), iaWarning && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_7___default().createElement(\"div\", {
    style: {
      color: \"#333\",
      backgroundColor: \"#ffe0b2\",
      padding: \"10px\",
      textAlign: \"center\",
      fontSize: \"13px\",
      fontWeight: \"500\",
      borderRadius: \"6px\",
      marginBottom: \"4px\",
      transition: \"all 0.3s ease\"
    }
  }, iaWarning), iaWarning && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_7___default().createElement(\"div\", {
    style: {
      color: \"#333\",
      backgroundColor: \"#ffe0b2\",
      padding: \"10px\",
      textAlign: \"center\",
      fontSize: \"13px\",
      fontWeight: \"500\",
      borderRadius: \"6px\",
      marginBottom: \"4px\",
      transition: \"all 0.3s ease\"
    }
  }, iaWarning), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_7___default().createElement(\"div\", {
    style: {
      flex: 1,
      overflowY: \"auto\",
      display: \"flex\",
      flexDirection: \"column\",
      gap: \"8px\",
      padding: \"16px\",
      position: \"relative\"
    }
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_7___default().createElement(\"div\", {
    style: {
      fontSize: \"10.5px\",
      color: isColorDark(backgroundColor) ? \"#e0e0e0\" : \"#a3a0a0ff\",
      backgroundColor: isColorDark(backgroundColor) ? \"rgba(255, 255, 255, 0.07)\" : \"rgba(0, 0, 0, 0.04)\",
      padding: \"10px 16px\",
      borderRadius: \"14px\",
      width: \"100%\",
      // ðŸ”„ hace que ocupe todo el ancho del chat
      margin: \"-6px 0 10px 0\",
      // ðŸ”½ margen superior reducido, espacio inferior normal
      textAlign: \"center\",
      // ðŸ” centrado opcional
      boxSizing: \"border-box\" // ðŸ§± asegura que padding no desborde
    }
  }, \"Nuestro asistente virtual est\\xE1 potenciado por IA y supervisi\\xF3n humana para ofrecer respuestas precisas y seguras.\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_7___default().createElement(_chat_MessageList__WEBPACK_IMPORTED_MODULE_14__[\"default\"], {
    messages: messages,
    messageRefs: messageRefs,
    fontFamily: fontFamily,
    openImageModal: openImageModal,
    isTyping: isTyping,
    typingSender: typingSender,
    typingRef: typingRef,
    primaryColor: primaryColor,
    secondaryColor: secondaryColor,
    isMobileView: isMobileView
  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_7___default().createElement(\"div\", {
    ref: messagesEndRef
  })), showInactivityMessage && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_7___default().createElement(\"div\", {
    style: {
      position: \"absolute\",
      top: \"50%\",
      left: \"50%\",
      transform: \"translate(-50%, -50%)\",
      zIndex: 1000,
      backgroundColor: \"rgba(255, 255, 255, 0.97)\",
      border: \"2px solid #ef5350\",
      borderRadius: \"16px\",
      padding: \"24px 28px 28px\",
      textAlign: \"center\",
      boxShadow: \"0 8px 32px rgba(0, 0, 0, 0.2)\"
    }
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_7___default().createElement(\"div\", {
    style: {
      color: \"#333\",
      fontSize: \"16px\",
      fontWeight: \"600\",
      marginBottom: \"12px\"
    }
  }, \"Conversaci\\xF3n por expirar\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_7___default().createElement(\"div\", {
    style: {
      color: \"#666\",
      fontSize: \"13px\",
      marginBottom: \"16px\",
      lineHeight: 1.4
    }
  }, \"Por inactividad la conversaci\\xF3n se cerrar\\xE1. Interact\\xFAa con el chat para continuar.\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_7___default().createElement(\"div\", {
    style: {
      color: \"#b71c1c\",
      fontSize: \"56px\",
      fontWeight: \"700\",
      lineHeight: 1,
      marginBottom: \"4px\"
    }
  }, inactivityCountdown ?? INACTIVITY_COUNTDOWN_SEC), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_7___default().createElement(\"div\", {
    style: {
      color: \"#c62828\",
      fontSize: \"14px\",
      fontWeight: \"500\"
    }
  }, \"segundos\")), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_7___default().createElement(_chat_InputArea__WEBPACK_IMPORTED_MODULE_12__[\"default\"], {
    key: `${effectiveStyle.allowImageUpload}-${effectiveStyle.allowFileUpload}-${fileInputKey}`,
    inputText: inputText,
    inputBg: inputBg,
    inputBorder: inputBorder,
    fontFamily: fontFamily,
    message: message,
    setMessage: setMessage,
    textareaRef: textareaRef,
    sendMessage: sendMessage,
    connectionRef: connectionRef,
    conversationId: conversationId,
    userId: userId,
    isInputDisabled: isInputDisabled || isBlockedByOtherDevice && !isMobileView // ðŸ”¹ Deshabilitar si demo, sin conexiÃ³n o sesiÃ³n mÃ³vil o bloqueado por mÃ³vil
    ,
    disabledPlaceholder: inputDisabledPlaceholder,
    allowImageUpload: effectiveStyle.allowImageUpload,
    allowFileUpload: effectiveStyle.allowFileUpload,
    onFileSent: handleFileSent,
    onUserActivity: handleUserActivity
  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_7___default().createElement(\"div\", {
    style: {
      textAlign: \"right\",
      fontSize: \"11px\",
      color: \"#999\",
      paddingBottom: \"8px\",
      marginRight: \"15px\",
      fontFamily: fontFamily || \"Arial\",
      display: \"flex\",
      justifyContent: \"flex-end\",
      alignItems: \"center\",
      gap: \"4px\"
    }
  }, \"\\xA9 \", new Date().getFullYear(), \" \", /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_7___default().createElement(\"b\", {
    style: {
      color: primaryColor,
      display: \"flex\",
      alignItems: \"center\",
      gap: \"4px\"
    }
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_7___default().createElement(\"img\", {
    src: viaLogo,
    alt: \"Logo VIA\",
    style: {
      width: \"20px\",
      height: \"20px\",
      objectFit: \"contain\"
    }
  })), \". Todos los derechos reservados.\"), isBlockedByOtherDevice && !isMobileView && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_7___default().createElement(_chat_DeviceConflictOverlay__WEBPACK_IMPORTED_MODULE_17__[\"default\"], {
    isBlocked: true,
    blockMessage: blockMessage || \"ConversaciÃ³n abierta en mÃ³vil. Por favor, continÃºa desde ahÃ­.\"
  }), showDeviceConflictOverlay && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_7___default().createElement((react__WEBPACK_IMPORTED_MODULE_7___default().Fragment), null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_7___default().createElement(_chat_DeviceConflictOverlay__WEBPACK_IMPORTED_MODULE_17__[\"default\"], {
    isBlocked: true,
    blockMessage: blockMessage || \"ConversaciÃ³n abierta en mÃ³vil. Por favor, continÃºa desde ahÃ­.\"
  })), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_7___default().createElement(_chat_ImagePreviewModal__WEBPACK_IMPORTED_MODULE_16__[\"default\"], {
    isOpen: isImageModalOpen,
    onClose: () => setIsImageModalOpen(false),
    imageGroup: imageGroup,
    imageGroupBlobUrls: imageGroupBlobUrls,
    activeImageIndex: activeImageIndex,
    setActiveImageIndex: setActiveImageIndex
  })));
}

// âœ… PropTypes
ChatWidget.propTypes = {
  botId: (prop_types__WEBPACK_IMPORTED_MODULE_9___default().number).isRequired,
  style: (prop_types__WEBPACK_IMPORTED_MODULE_9___default().object),
  userId: prop_types__WEBPACK_IMPORTED_MODULE_9___default().oneOfType([(prop_types__WEBPACK_IMPORTED_MODULE_9___default().string), (prop_types__WEBPACK_IMPORTED_MODULE_9___default().number)]),
  widgetToken: (prop_types__WEBPACK_IMPORTED_MODULE_9___default().string),
  widgetClientSecret: (prop_types__WEBPACK_IMPORTED_MODULE_9___default().string),
  title: (prop_types__WEBPACK_IMPORTED_MODULE_9___default().string),
  theme: prop_types__WEBPACK_IMPORTED_MODULE_9___default().oneOf([\"light\", \"dark\", \"custom\"]),
  primaryColor: (prop_types__WEBPACK_IMPORTED_MODULE_9___default().string),
  secondaryColor: (prop_types__WEBPACK_IMPORTED_MODULE_9___default().string),
  headerBackgroundColor: (prop_types__WEBPACK_IMPORTED_MODULE_9___default().string),
  fontFamily: (prop_types__WEBPACK_IMPORTED_MODULE_9___default().string),
  avatarUrl: (prop_types__WEBPACK_IMPORTED_MODULE_9___default().string),
  isDemo: (prop_types__WEBPACK_IMPORTED_MODULE_9___default().bool),
  isMobileView: (prop_types__WEBPACK_IMPORTED_MODULE_9___default().bool),
  conversationId: prop_types__WEBPACK_IMPORTED_MODULE_9___default().oneOfType([(prop_types__WEBPACK_IMPORTED_MODULE_9___default().string), (prop_types__WEBPACK_IMPORTED_MODULE_9___default().number)]),
  position: prop_types__WEBPACK_IMPORTED_MODULE_9___default().oneOf([\"bottom-right\", \"bottom-left\", \"top-right\", \"top-left\", \"center-left\", \"center-right\"]),
  previewMode: (prop_types__WEBPACK_IMPORTED_MODULE_9___default().bool),
  // Optional refs/sizing used by the widget-frame handshake
  rootRef: (prop_types__WEBPACK_IMPORTED_MODULE_9___default().any),
  containerSize: (prop_types__WEBPACK_IMPORTED_MODULE_9___default().object)
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ChatWidget);

//# sourceURL=webpack://ViaWidget/./src/layouts/bot/style/components/ChatWidget.js?
}
